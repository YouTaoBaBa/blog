<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CascadePSP</title>
      <link href="/2020/11/17/cascadepsp/"/>
      <url>/2020/11/17/cascadepsp/</url>
      
        <content type="html"><![CDATA[<h1 id="CascadePSP-Toward-Class-Agnostic-and-Very-High-Resolution-Segmentation-via-Global-and-Local-Refinement"><a href="#CascadePSP-Toward-Class-Agnostic-and-Very-High-Resolution-Segmentation-via-Global-and-Local-Refinement" class="headerlink" title="CascadePSP: Toward Class-Agnostic and Very High-Resolution Segmentation via Global and Local Refinement"></a>CascadePSP: Toward Class-Agnostic and Very High-Resolution Segmentation via Global and Local Refinement</h1><p>通过全局和局部细化实现类不可知和非常高分辨率的分割</p><p><a href="https://arxiv.org/abs/2005.02551" target="_blank" rel="noopener">论文地址</a></p><p><a href="https://github.com/hkchengrex/CascadePSP" target="_blank" rel="noopener">代码地址</a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>语义分割一般只训练固定分辨率范围内的图像，通过对低分辨率图像上采样得到高分辨率图像是不足以描述高分辨率图像细节的。</li><li>受限于显存，低分辨率的模型没法推广到高分辨率情况</li><li>超分辨率图像标注难以获取</li><li>目前的超分图分割主要方法包括下采样和裁剪，下采样方法消除了细节信息，裁剪方法破坏了图像块之间的上下文信息</li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>提出了CascadePSP，这是一种通用的级联分割细化模型，它可以细化任何给定的输入分割，在不进行微调的情况下提高先进分割模型的性能。</li><li>证明了该方法可以产生高质量和高分辨率的分割，这是以前基于深度学习的方法所不能实现的。</li><li>做了个数据集，叫BIG dataset，有50个验证和100个测试，它可以作为一个精确的评价数据集用于非常高分辨率的语义图像分割任务。</li></ul><h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p>全卷积网络（FCN），通过自下而上的，带有广视野的上下文信息</p><p>特征金字塔（PSP），使用不同尺度的图像、或者是源于空间池化、拓展卷积等获得的不同感受野特征</p><p>编码器解码器（Encoder-Decoder），先减少维度捕获高级语义，然后使用解码器回复空间范围，再加上跳跃链接获得更清晰的边界。</p><h3 id="细化分割"><a href="#细化分割" class="headerlink" title="细化分割"></a>细化分割</h3><p>基于FCN的方法通常不会产生高质量的分割。研究人员已经用图结构模型解决了这个问题，如条件随机场（CRF）或区域生长。它们通常坚持低层次的颜色边界，而没有充分利用高级语义信息，并且不能修复较大的错误区域。由于计算和内存的限制，基于传播的方法不能处理非常高分辨率的数据。单独的细分模块也被用于提高边界精度，他们的模型接受的是端到端的训练，这种方法的模型，使用大模型容易出现过拟合，而浅层优化网络的优化能力有限。</p><h3 id="级联网络"><a href="#级联网络" class="headerlink" title="级联网络"></a>级联网络</h3><p>多尺度分析在许多计算机视觉任务中同时利用了大尺度和小尺度特征，如边缘检测、目标检测和分割。特别是，有许多方法在每个阶段预测独立的结果，并将它们合并以获得多尺度信息。我们的方法不仅从粗糙的尺度中融合特征，而且使用它们作为下一个更精细的层次的输入之一。文章证明，添加粗的输出作为下一层的输入并不会改变系统模型，因此同样的网络可以递归地用于更高分辨率的细化。</p><h2 id="CascadePSP"><a href="#CascadePSP" class="headerlink" title="CascadePSP"></a>CascadePSP</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分辨率语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql语法记录</title>
      <link href="/2020/10/18/mysql-yu-fa-ji-lu/"/>
      <url>/2020/10/18/mysql-yu-fa-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h1><pre class=" language-lang-sql"><code class="language-lang-sql">show databases; --查看数据库use school; --切换到school数据库show tables; --查看数据表describe student;--显示数据库中，表的信息,表结构desc student;--显示数据库中，表的信息,表结构create database if not exists newdbname;--创建一个数据库drop database if exists newdbname;--创建一个数据库create table if not exists `newtable`(    `id` int(4) not null auto_increment comment `学号`,    `name` varchar(30) not null default `匿名` comment `姓名`,    `pwd` varchar(20) not null default `123456` comment `密码`    primary key(`id`))engine=innoob default charset=utf8alter table tablename rename as newtable--修改表名--增加表的字段 alter:table 表名 add 字段名 列属性alter table tablename add age int(11) --增加表的字段 add 字段名 列属性--修改表的字段的约束:alter table 表名 modify 字段名 列属性alter table tablename modify age varchar(11)--修改表中字段的约束--修改表的字段的名字:alter table 表名 change 字段名 新的字段名 列属性alter table tablename change age age1 int(1)--字段重命名--删除表的字段:alter table 表名 drop 字段名alter table tablename drop age--删除表的字段--不推荐使用外键，建议在应用层实现--增加外键:alter table 表名 add constraint `FK_gradeid` foreign key(作为外键的列) references 那个表名(哪个字段)alter table `student` add constraint `FK_gradeid` foreign key(`gradeid`) references `grade`(`gradeid`)--由于主键自增，可以省略主键（如果不写表的字段，他会一一匹配）--insert into 表名([字段名1,字段名2,...])values('值1','值2',...)insert into `grade`(`gradename`,`name`)values('研二','aaa'),('研一','bbb')--update 表名 set 列名=新值[,colnum_name=value,...] where 条件update `student` set `name` = 'aaaaa',`email`='123123@qq.com' where id = 1;--清空数据表truncate `student`--重新设置自增列，不会影响事务delete from `student`--不会重新设置自增列--删除指定数据delete from `student` where id=1;--查询全部学生 select 字段(可以是表达式) from 表select * from student --查询指定字段select `StudentNo`,`StudentName` from studentselect `StudentNo` as 学号,`StudentName` as 学生姓名 from student as s--使用as起别名--select concat(a,b) as 新名字 from 表select concat('姓名：'StudentName) as 新名字 from student--select去重select distinct `StudentNo` from result--where 模糊查询 like   %：任意数量字符，_:单个字符select `StudentNo` from `student` where `StudentName` like ')刘%'--where 查询多个结果 inselect `StudentNo` from `student` where `address` in ('安徽','湖南')--inner join如果表中至少有一个匹配行，--left join从左表中返回所有的值，即使右表中没有匹配--right join从右表中返回所有的值，即使左表中没有匹配--on 用于多表，返回单表后用whereselect s.StudentNo,studentName from student as sinner join result as ron s.StudentNo=r.StudentNo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM探究</title>
      <link href="/2020/10/17/jvm-tan-jiu/"/>
      <url>/2020/10/17/jvm-tan-jiu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM探究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解与反射</title>
      <link href="/2020/09/27/zhu-jie-yu-fan-she/"/>
      <url>/2020/09/27/zhu-jie-yu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li>不是程序本身，可以对程序作出解释</li><li>可以被其他程序（比如：编译器）读取。<h2 id="注解的格式"><a href="#注解的格式" class="headerlink" title="注解的格式"></a>注解的格式</h2>@注解名（参数）如：</li><li>重写：@Override、函数式接口@FunctionalInterface</li><li>带参例子：@SuppressWarnings(value=”unchecked”)<h2 id="在哪使用"><a href="#在哪使用" class="headerlink" title="在哪使用"></a>在哪使用</h2>package,class,method,field等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul><li>@Override：重写；</li><li>@Deprecated：不鼓励程序员使用，或者使用更好的方式，弃用的；</li><li>@SuppressWarnings(“all”)：抑制编译时候带来的warning信息。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>注解其他注解的注解</p><ul><li>@Target：用于描述注解的适用范围（即：被描述的注解可以用在什么地方）</li><li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）</li><li>@Document:说明该注解将被包含在javadoc中</li><li>@Inherited:表示子类可以继承父类的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><pre class=" language-lang-java"><code class="language-lang-java">public class Annotation {    @MyAnnotation(name = "666",schools = {"牛逼"})//注解可以显示赋值，如果没有默认值则必须赋值    public void test(){    }}@Target({ElementType.TYPE,ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation{    String name() default "";//注解的参数，参数类型+参数名    int age() default 1;    String[] schools();}</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>动态语言：可以在运行时根据某些条件改变自身结构，如：js，python，php等</li><li>静态语言：运行时结构不可变的语言，如：Java，C/C++</li><li>Java可通过反射实现一定的动态性</li><li><p>类、接口、数组、枚举、注解、基本数据类型、void均可以有Class对象</p><pre class=" language-lang-java"><code class="language-lang-java">  public static void test(){      Class c1 = MyAnnotation.class;//注解      Class c2 = Object.class;//类      Class c3 = Comparable.class;//接口      System.out.println(c1);      System.out.println(c2);      System.out.println(c3);  }</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解与反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程</title>
      <link href="/2020/09/27/java-wang-luo-bian-cheng/"/>
      <url>/2020/09/27/java-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="网络处理"><a href="#网络处理" class="headerlink" title="网络处理"></a>网络处理</h1><h2 id="TCP聊天"><a href="#TCP聊天" class="headerlink" title="TCP聊天"></a>TCP聊天</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;public class Client {    public static void main(String[] args) {        Socket socket = null;        OutputStream os = null;        try{            InetAddress serverIP = InetAddress.getByName("127.0.0.1");            int port = 9999;            socket = new Socket(serverIP,port);            os = socket.getOutputStream();            os.write("66666".getBytes());        }catch (Exception e){            e.printStackTrace();        }finally {            if (os != null) {                try {                    os.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (socket != null) {                try {                    socket.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = null;        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try{            serverSocket = new ServerSocket(9999);            while (true){                socket = serverSocket.accept();                is = socket.getInputStream();                baos = new ByteArrayOutputStream();                byte[] buffer = new byte[1024];                int len;                while((len=is.read(buffer))!=-1){                    baos.write(buffer,0,len);                }                System.out.println(baos.toString());            }        }catch (IOException e){            System.out.println(e.toString());        }finally {            if (baos != null) {                baos.close();            }            if (is != null) {                is.close();            }            if (socket != null) {                socket.close();            }            if (serverSocket != null) {                serverSocket.close();            }        }    }}</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class FileAccept {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(9000);        Socket socket = serverSocket.accept();        InputStream is = socket.getInputStream();        FileOutputStream fos = new FileOutputStream(new File("receive.jpg"));        byte[] buffer = new byte[100000];        int len;        while((len=is.read(buffer))!=-1) {            fos.write(buffer, 0, len);        }        fos.close();        is.close();        socket.close();        serverSocket.close();    }}</code></pre><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import com.sun.org.apache.xml.internal.serializer.OutputPropertyUtils;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class FileUpload {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9000);        OutputStream os = socket.getOutputStream();        FileInputStream fis = new FileInputStream(new File("111.jpg"));        byte[] buffer = new byte[100000];        int len;        while((len=fis.read(buffer))!=-1){            os.write(buffer,0,len);        }        fis.close();        os.close();        socket.close();    }}</code></pre><h2 id="UDP发送"><a href="#UDP发送" class="headerlink" title="UDP发送"></a>UDP发送</h2><pre class=" language-lang-java"><code class="language-lang-java">InetAddress localhost = InetAddress.getByName("localhost");int port = 9999;String msg = "你好";DatagramSocket socket = new DatagramSocket();DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,(msg.getBytes().length,localhost,port);socket.send(packet);socket.close();</code></pre><h2 id="URL下载网络资源"><a href="#URL下载网络资源" class="headerlink" title="URL下载网络资源"></a>URL下载网络资源</h2><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class URLDemo {    public static void main(String[] args) throws IOException {        URL url = new URL("https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mMDZjNzU2NS0wZjg0LTQzNmItOGVlNy1hY2Y2ZjliN2VjMDIucG5n?x-oss-process=image/format,png");        System.out.println(url.getProtocol());//协议        System.out.println(url.getHost());//主机        System.out.println(url.getPort());//端口        System.out.println(url.getPath());//文件地址        System.out.println(url.getFile());//文件全路径        System.out.println(url.getQuery());//参数        //连接        HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();        InputStream inputStream = urlConnection.getInputStream();        FileOutputStream fileOutputStream = new FileOutputStream("112.png");        byte[] buffer = new byte[1024];        int len;        while ((len=inputStream.read(buffer))!=-1){            fileOutputStream.write(buffer,0,len);        }        fileOutputStream.close();        inputStream.close();        urlConnection.disconnect();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model-Based协同过滤算法</title>
      <link href="/2020/09/26/model-based-xie-tong-guo-lu-suan-fa/"/>
      <url>/2020/09/26/model-based-xie-tong-guo-lu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Model-Based协同过滤算法"><a href="#Model-Based协同过滤算法" class="headerlink" title="Model-Based协同过滤算法"></a>Model-Based协同过滤算法</h1><ul><li>基于分类算法、回归算法、聚类算法</li><li>基于矩阵分解的推荐</li><li>基于神经网络</li><li>基于图模型</li></ul><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p>这个用户或物品普遍高于或低于平均值的差值，成为偏差（bias）。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>找出每个用户普遍高于或低于他人的偏置值$b_{u}$</li><li>找出每件物品普遍高于或低于其他物品的偏置值$b_{i}$</li><li>目标转换为寻找最优的$b_{u}$和$b_{i}$</li></ul><h3 id="预测步骤"><a href="#预测步骤" class="headerlink" title="预测步骤"></a>预测步骤</h3><ul><li>计算所有电影的均分$\mu$</li><li>计算每个用户评分与平均评分$\mu$的偏置值$b_{u}$</li><li>计算每部电影所接受的评分与平均评分$\mu$的偏置值$b_{I}$</li><li>预测用户对电影的评分：<script type="math/tex; mode=display">\hat{r}_{ui}=b_{ui}=\mu + b_{u}+b_{i}</script></li><li>转换为损失优化的过程<script type="math/tex; mode=display">J(\theta)=Cost=f(b_{u},b_{i})</script><script type="math/tex; mode=display">J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu -b_{u}-b_{i})^2+\lambda *(\sum_{u}{b_{u}}^2+\sum_{i}{b_{i}}^2)</script></li></ul><h2 id="FunkSVD-LFM"><a href="#FunkSVD-LFM" class="headerlink" title="FunkSVD(LFM)"></a>FunkSVD(LFM)</h2><p>原始的SVD要求矩阵中每个元素非空，如果做填充，会造成大量噪声，破坏原始分布。</p><ul><li><p>P为User-LF矩阵，即用户-隐藏特征矩阵</p></li><li><p>Q为Item-LF矩阵</p></li><li><p>R=P*Q，为User-Item矩阵</p></li><li><p>能处理稀疏评分矩阵</p></li></ul><p>利用矩阵分解技术，将原始User-Item评分矩阵分解为P、Q，然后用P、Q利用梯度下降去还原R，整个过程相当于降维。</p><h2 id="BiasSVE"><a href="#BiasSVE" class="headerlink" title="BiasSVE"></a>BiasSVE</h2><p>矩阵分解+baseline思想</p><h2 id="SVD"><a href="#SVD" class="headerlink" title="SVD++"></a>SVD++</h2><p>矩阵分解+baseline思想+其他影响（点击、收藏、购买）</p>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model-Based协同过滤算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内容的推荐</title>
      <link href="/2020/09/26/ji-yu-nei-rong-de-tui-jian/"/>
      <url>/2020/09/26/ji-yu-nei-rong-de-tui-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h1><ul><li>给物品打标签<ul><li>系统自己提取，从业务数据库中提取</li><li>用户填写</li><li>中文分词 利用算法计算词的权重<ul><li>tf-idf:$\quad tf*idf$<ul><li>tf:term frequency词频</li><li>idf:逆文档频率 $log_{10}\frac{t}{n}$</li></ul></li><li>textrank</li></ul></li></ul></li><li>利用标签的文字，转换为词向量<ul><li>word2vec 词-&gt;向量</li><li>用向量表示语义</li><li>如果两个词向量的相似度高，认为两词语义相近</li></ul></li><li>利用词向量，构建物品的向量<ul><li>一个物品有N个关键词，每一个关键词对应一个词向量</li><li>求和（权重*词向量）/N</li><li>利用N个关键词的词向量获取物品向量</li></ul></li><li>通过物品向量计算相似度<ul><li>皮尔逊 相关系数 计算物品向量的相似度</li></ul></li></ul><h2 id="基于内容的推荐与基于物品的协同过滤的区别"><a href="#基于内容的推荐与基于物品的协同过滤的区别" class="headerlink" title="基于内容的推荐与基于物品的协同过滤的区别"></a>基于内容的推荐与基于物品的协同过滤的区别</h2><ul><li>基于内容：词向量-&gt;物品向量-&gt;计算相似度</li><li>基于物品：用户-物品矩阵-&gt;物品向量-&gt;相似度</li><li>差异：<ul><li>物品向量构建过程不同</li><li>基于内容<ul><li>物品向量 文本（物品描述信息，系统填标签，用户填标签）</li></ul></li><li>基于物品<ul><li>用户对物品的评分矩阵，用户的行为数据</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memory-Based推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统评估</title>
      <link href="/2020/09/26/tui-jian-xi-tong-ping-gu/"/>
      <url>/2020/09/26/tui-jian-xi-tong-ping-gu/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统评估"><a href="#推荐系统评估" class="headerlink" title="推荐系统评估"></a>推荐系统评估</h1><h2 id="常用评估指标"><a href="#常用评估指标" class="headerlink" title="常用评估指标"></a>常用评估指标</h2><p>准确性、信任度、满意度、实时性、覆盖率、鲁棒性、多样性、可拓展性、新颖性、商业目标、惊喜度、用户留存。</p><h2 id="准确性（理论角度）"><a href="#准确性（理论角度）" class="headerlink" title="准确性（理论角度）"></a>准确性（理论角度）</h2><ul><li>评分预测<br>RMSE MAE</li><li>topN推荐<br>召回率、精准率<h2 id="覆盖度"><a href="#覆盖度" class="headerlink" title="覆盖度"></a>覆盖度</h2></li><li>信息熵，越大越好</li><li>覆盖率<h2 id="多样性-amp-新颖性-amp-惊喜性"><a href="#多样性-amp-新颖性-amp-惊喜性" class="headerlink" title="多样性&amp;新颖性&amp;惊喜性"></a>多样性&amp;新颖性&amp;惊喜性</h2>往往会牺牲准确性<h3 id="Exploitation-amp-Exploration探索与利用问题"><a href="#Exploitation-amp-Exploration探索与利用问题" class="headerlink" title="Exploitation &amp; Exploration探索与利用问题"></a>Exploitation &amp; Exploration探索与利用问题</h3></li><li>(Exploitation)开发、利用：选择现在可能的最佳方案</li><li>(Exploration)探索、搜索：选择现在不确定的一些方案，但未来可能会有高收益的方案</li><li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化长期的目标</li></ul><h3 id="EE问题实践"><a href="#EE问题实践" class="headerlink" title="EE问题实践"></a>EE问题实践</h3><ul><li>兴趣拓展：相似话题，搭配推荐</li><li>人群算法：userCF用户聚类</li><li>平衡个性化推荐和热门推荐比例</li><li>随机丢弃用户行为历史</li><li>随机扰动模型参数<h3 id="EE带来的可能问题"><a href="#EE带来的可能问题" class="headerlink" title="EE带来的可能问题"></a>EE带来的可能问题</h3></li><li>伤害用户体验</li><li>评估周期长</li><li>如何平衡实时兴趣和长期兴趣</li><li>如何平衡短期产品体验和长期系统生态</li><li>如何平衡大众口味和小众需求<h3 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h3></li><li>问卷</li><li>离线评估<ul><li>只能在用户看到过得候选集上评估（RMSE MAE），且跟线上真实效果存在偏差</li><li>只能评估少数指标</li><li>速度快，不影响用户体验</li></ul></li><li>在线评估：灰度发布&amp;A/B测试50%全量上线（类似于内测）</li><li>实践：离线评估和在线评估，定期做问卷调查</li></ul><h2 id="冷启动问题"><a href="#冷启动问题" class="headerlink" title="冷启动问题"></a>冷启动问题</h2><p>新用户，新物品，没有相关积累数据</p><h3 id="用户冷启动"><a href="#用户冷启动" class="headerlink" title="用户冷启动"></a>用户冷启动</h3><ul><li>收集用户特征<ul><li>注册信息</li><li>社交信息</li><li>定位、型号、app列表</li></ul></li><li>引导用户填写兴趣</li><li>用户在其他站点的行为</li><li>新老用户推荐策略的差异<ul><li>新用户在冷启动阶段更倾向于热门排行榜，老用户更需要长尾推荐</li><li>Explore Exploit力度</li><li>使用单独的特征和模型预估<h3 id="物品冷启动"><a href="#物品冷启动" class="headerlink" title="物品冷启动"></a>物品冷启动</h3></li></ul></li><li>物品打标签，构建物品画像</li><li>基于内容的推荐<h3 id="系统冷启动"><a href="#系统冷启动" class="headerlink" title="系统冷启动"></a>系统冷启动</h3></li><li>如果缺少用户行为数据-&gt;基于内容的推荐</li><li>随着用户行为积累越来越多-&gt;协同过滤</li><li>基于内容和协同过滤共同工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法评估 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法——协同过滤</title>
      <link href="/2020/09/15/tui-jian-suan-fa-xie-tong-guo-lu/"/>
      <url>/2020/09/15/tui-jian-suan-fa-xie-tong-guo-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="经典：协同过滤推荐算法"><a href="#经典：协同过滤推荐算法" class="headerlink" title="经典：协同过滤推荐算法"></a>经典：协同过滤推荐算法</h1><p>算法思想：物以类聚，人以群分。<br>基本假设：</p><ul><li>喜好相似的人洗好的东西你也很可能喜欢：基于用户的协同过滤推荐（User-based CF）</li><li>跟你喜欢的东西相似的东西你也很可能喜欢：基于物品的协同过滤推荐（item-based CF）</li></ul><h1 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h1><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><p>余弦相似性通过测量两个向量的夹角的余弦值来度量它们之间的相似性。0度角的余弦值是1，而其他任何角度的余弦值都不大于1；并且其最小值是-1。从而两个向量之间的角度的余弦值确定两个向量是否大致指向相同的方向。两个向量有相同的指向时，余弦相似度的值为1；两个向量夹角为90°时，余弦相似度的值为0；两个向量指向完全相反的方向时，余弦相似度的值为-1。这结果是与向量的长度无关的，仅仅与向量的指向方向相关。余弦相似度通常用于正空间，因此给出的值为0到1之间。</p><script type="math/tex; mode=display">\cos(\theta)=\frac{A \cdot B}{||A|| \cdot ||B||}</script><h2 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h2><p>本质上也是余弦相似度，用以度量两个变量是否是同增同减，主要衡量变量之间的变化趋势是否一致，不适合计算布尔值向量之间的相关度。</p><p>对余弦相似度所用的向量的每一个分量做中心化。</p><p>如果评分数据是连续的数值，比较适合余弦和皮尔逊</p><h2 id="杰卡德相似度"><a href="#杰卡德相似度" class="headerlink" title="杰卡德相似度"></a>杰卡德相似度</h2><p>计算适用于$bool$类型数据</p><script type="math/tex; mode=display">J(A,B)=\frac{|A \cap B|}{|A \cup B|}</script><h2 id="评分预测"><a href="#评分预测" class="headerlink" title="评分预测"></a>评分预测</h2><h3 id="基于用户"><a href="#基于用户" class="headerlink" title="基于用户"></a>基于用户</h3><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\frac{\sum{v\in U}sim(u,v)*r_{vi}}{\sum{v \in U}|sim(u,v)|}</script><h3 id="基于物品"><a href="#基于物品" class="headerlink" title="基于物品"></a>基于物品</h3><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\frac{\sum{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum{j \in I_{rate}}|sim(i,j)|}</script><h2 id="基于模型的协同过滤算法"><a href="#基于模型的协同过滤算法" class="headerlink" title="基于模型的协同过滤算法"></a>基于模型的协同过滤算法</h2><h3 id="基于图模型"><a href="#基于图模型" class="headerlink" title="基于图模型"></a>基于图模型</h3><ul><li>将用户行为数据表示为二分图</li><li>基于二分图为用户进行推荐</li><li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li></ul><h3 id="基于矩阵分解的方法"><a href="#基于矩阵分解的方法" class="headerlink" title="基于矩阵分解的方法"></a>基于矩阵分解的方法</h3><ul><li>适用于解决稀疏数据</li><li>将M×N的用户-物品矩阵分解为M×K的用户矩阵和K×N的物品矩阵，取出第一行的1×K和第一列的K×1做点乘即为第一个用户对第一个物品的得分。</li><li>分解后的两矩阵相乘应尽可能等于原矩阵，损失函数为原矩阵与分解后重新乘起来的矩阵的L2距离。（利用ALS,交替最小二乘法优化)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memory-Based推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2020/09/12/java-duo-xian-cheng/"/>
      <url>/2020/09/12/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>线程开启不一定立即执行，由CPU调度</p><ul><li>继承Thread类，重写run()方法，调用start开启线程</li><li>通过实现MyRunnable接口<ol><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法</li><li>通过Thread类调用<pre class=" language-lang-java"><code class="language-lang-java">new Thread(threadname).start()</code></pre></li></ol></li><li>通过实现Callable接口(可以有返回值，可以抛出异常)<ol><li>定义TestCallable类实现Callable接口</li><li>实现call()方法,拥有返回值</li><li>创建执行服务、提交执行、获取结果、关闭服务<pre class=" language-lang-java"><code class="language-lang-java">TestCallable t1 = new TestCallable();TestCallable t2 = new TestCallable();TestCallable t3 = new TestCallable();//创建执行服务ExecutorService ser = Executors.newFixedThreadPool(nThreads);//提交执行Future<Boolean> r1 = ser.submit(t1);Future<Boolean> r2 = ser.submit(t2);Future<Boolean> r3 = ser.submit(t3);//获取结果boolean rs1 = r1.get();boolean rs2 = r2.get();boolean rs3 = r3.get();//关闭服务ser.shutdownNow();</code></pre><h2 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h2><pre class=" language-lang-java"><code class="language-lang-java">Thread.currentThread().getName()#获取线程名;</code></pre><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li></ol></li><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要代理真实角色<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3></li><li>代理对象可以做很多真实对象做不了的事情</li><li>真实对象专注做自己的事情</li></ul><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用jdk提供的stop()、destroy()等过时方法。</p><h4 id="设置外部标志位"><a href="#设置外部标志位" class="headerlink" title="设置外部标志位"></a>设置外部标志位</h4><ol><li>设置外部标志位</li><li>设置一个公开的方法停止线程————转换标志位<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4></li></ol><ul><li>sleep存在异常InterruptedException</li><li>每个对象都有一个锁sleep不会释放锁<pre class=" language-lang-java"><code class="language-lang-java">try {  Thread.sleep(50);//括号内为毫秒数} catch (InterruptedException e) {  e.printStackTrace();}</code></pre><h4 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h4>礼让不一定成功<pre class=" language-lang-java"><code class="language-lang-java">class A implements Runnable{  @Override  public void run() {      System.out.println("yingyihg");      Thread.yield();      System.out.println("111");  }}</code></pre><h4 id="线程强制执行-插队"><a href="#线程强制执行-插队" class="headerlink" title="线程强制执行(插队)"></a>线程强制执行(插队)</h4><pre class=" language-lang-java"><code class="language-lang-java">thread.join();</code></pre><h4 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h4><pre class=" language-lang-java"><code class="language-lang-java">state = thread.getState();//state == Thread.State.TERMINATED;</code></pre><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><pre class=" language-lang-java"><code class="language-lang-java">//查看优先级Thread.currentThread.getPriority();//设置优先级thread.setPriority(1);thread.setPriority(Thread.MAX_PRIORITY);</code></pre><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4>线程分为用户线程和守护线程，虚拟机需要等待用户线程执行完毕而不会等待守护线程，守护线程用于垃圾回收，监控内存，后台日志记录等。<pre class=" language-lang-java"><code class="language-lang-java">thread.setDaemon(true);</code></pre></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>并发：多线程操作同一个资源</p><h3 id="引入锁机制synchronized"><a href="#引入锁机制synchronized" class="headerlink" title="引入锁机制synchronized"></a>引入锁机制synchronized</h3><p>问题：</p><ul><li>线程持有锁会导致其他所有需要此锁的线程挂起；</li><li>多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题；</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。<pre class=" language-lang-java"><code class="language-lang-java">public pynchronized void run();//同步方法，默认锁thissynchronized(obj){  //同步代码块，所得对象就是变化的量，需要增删改查的。}</code></pre><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3>java.util,concurrent.locks.Lock接口是控制多个线程对共享资源访问的工具。<h4 id="ReentrantLock类-可重入锁"><a href="#ReentrantLock类-可重入锁" class="headerlink" title="ReentrantLock类 可重入锁"></a>ReentrantLock类 可重入锁</h4>该类实现了Lock，拥有和synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用，可显式加锁释放锁。<pre class=" language-lang-java"><code class="language-lang-java">class TestLock2 implements Runnable{  int ticketNums = 10;  private final ReentrantLock lock = new ReentrantLock();  @Override  public void run() {      while (true){          try{              lock.lock();              if(ticketNums>0){                  try {                      Thread.sleep(1000);                  } catch (InterruptedException e) {                      e.printStackTrace();                  }                  System.out.println(ticketNums--);              }else break;          }finally {              lock.unlock();          }      }  }}</code></pre><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="生产者消费者问题-可以参考操作系统"><a href="#生产者消费者问题-可以参考操作系统" class="headerlink" title="生产者消费者问题(可以参考操作系统)"></a>生产者消费者问题(可以参考操作系统)</h3></li><li>管程法</li><li><p>信号灯法</p><pre class=" language-lang-java"><code class="language-lang-java">if(flag){    this.wait();}//执行操作this.notifyAll();</code></pre><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><pre class=" language-lang-java"><code class="language-lang-java">public class TestProduceConsumer {  public static void main(String[] args) {      SynContainer container = new SynContainer();      new Productor(container).start();      new Consumer(container).start();  }}class Productor extends Thread{  SynContainer container;  public Productor(SynContainer container){      this.container = container;  }  public void run(){      for (int i = 0; i < 100; i++) {          container.push(new Product(i));          System.out.println("生产了"+i+"只鸡");      }  }}class Consumer extends Thread{  SynContainer container;  public Consumer(SynContainer container){      this.container = container;  }  @Override  public void run() {      for (int i = 0; i < 100; i++) {          System.out.println("消费了第"+container.pop().id+"只鸡");      }  }}class Product{  int id;  public Product(int id) {      this.id = id;  }}class SynContainer{  Product[] products = new Product[10];  int count = 0;  public synchronized void push(Product product){      if(count==products.length){          try {              this.wait();          } catch (InterruptedException e) {              e.printStackTrace();          }      }      products[count]=product;      count++;      this.notifyAll();  }  public synchronized Product pop(){      if(count==0){          try {              this.wait();          } catch (InterruptedException e) {              e.printStackTrace();          }      }      count--;      Product product = products[count];      this.notifyAll();      return product;  }}</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>背景：经常创建和销毁、使用量特别大的资源，比如并发下的线程，对性能影响很大。<br>思路：提前创建多线程，放入线程池，使用时直接获取，使用完放回池中。</p><pre class=" language-lang-java"><code class="language-lang-java">class MyThread implements Runnable{  @Override  public void run() {      System.out.println(Thread.currentThread().getName());  }}public class TestPool {  public static void main(String[] args) {      //创建服务，创建线程池,参数为线程池大小      ExecutorService service = Executors.newFixedThreadPool(10);      //执行      service.execute(new MyThread());      service.execute(new MyThread());      service.execute(new MyThread());      service.execute(new MyThread());      //关闭链接      service.shutdown();  }}</code></pre><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>任何一个接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p></li></ul><p>定义以下接口及其类的实现</p><pre class=" language-lang-java"><code class="language-lang-java">interface Ilike{    void lambda();}</code></pre><pre class=" language-lang-java"><code class="language-lang-java">//表达式只有一行的时候可以省略花括号//lambda使用前提是函数式接口//如果有一个或者多个参数，可以去掉参数类型，但得所有一起去，必须加上小括号Ilike like = ()->{    System.out.println("i like lambda5");}like.lambda();</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程及lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类</title>
      <link href="/2020/09/12/java-chang-yong-lei/"/>
      <url>/2020/09/12/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li>hashcode()</li><li>toString()</li><li>clone()</li><li>getClass()</li><li>notify()//唤起等待状态的线程</li><li>wait()//线程等待，与sleep不同在他会释放锁</li><li>equals()</li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>常见的数学运算</p><pre class=" language-lang-java"><code class="language-lang-java">System.out.println("90度的正弦值：" + Math.sin(Math.PI / 2));System.out.println("2的平方根与2商的反弦值:" + Math.asin(Math.sqrt(2)/2));System.out.println("e的平方值："+ Math.exp(2));System.out.println("以e为底2的对数值:" + Math.log(2));System.out.println("以10为底2的对数值:" + Math.log10(2));System.out.println("2的平方根:" + Math.sqrt(2));System.out.println("2的平方:" + Math.pow(2,2));System.out.println("不小于3.5的最小整数" + Math.ceil(3.5));System.out.println("不大于3.5的最大整数:" + Math.floor(3.5));System.out.println("3.5的四舍五入:" + Math.round(3.5));System.out.println("3.5最接近的整数为，同样接近取偶数：" + Math.rint(3.5));</code></pre><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>生成随机数</p><pre class=" language-lang-java"><code class="language-lang-java">Random r = new Random();//生成0-n之间随机整数int p = r.nextInt(n);//生成0-1之间随机doubledouble d1 = r.nextDouble();//设置随机种子r.setSeed(555L);</code></pre><h2 id="Data类"><a href="#Data类" class="headerlink" title="Data类"></a>Data类</h2><pre class=" language-lang-java"><code class="language-lang-java">Date d1 = new Date();//以正常形式创建当前日期d1long timeMillis = System.currentTimeMillis();//当前毫秒数Date d2 = new Date(timeMillis);//以毫秒数创建d2long value = d2.getTime();//获取当前时间（毫秒）System.out.println("日期" + d1);System.out.println("毫秒数" + value);</code></pre><p>输出结果为：</p><pre class=" language-lang-java"><code class="language-lang-java">日期Sat Sep 12 17:17:50 GMT+08:00 2020毫秒数1599902270831</code></pre><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><pre class=" language-lang-java"><code class="language-lang-java">DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss EE");DateFormat df2 = new SimpleDateFormat("yyyy年MM月dd日");Date date = new Date();System.out.println("格式化输出日期1：" + df1.format(date));System.out.println("格式化输出日期2：" + df2.format(date));</code></pre><p>输出结果为：</p><pre class=" language-lang-java"><code class="language-lang-java">格式化输出日期1：2020-09-12 06:37:56 星期六格式化输出日期2：2020年09月12日</code></pre><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><pre class=" language-lang-java"><code class="language-lang-java">Calendar c1 = Calendar.getInstance();c1.setTime(d1);         System.out.println(d);System.out.println(c1.get(Calendar.YEAR)+"年"+(c1.get(Calendar.MONTH)+1)+"月"+c1.get(Calendar.DATE)+"日");</code></pre><p>输出结果为：2020年9月12日</p><pre class=" language-lang-java"><code class="language-lang-java"></code></pre><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><p>创建文件对象</p><pre class=" language-lang-java"><code class="language-lang-java">File file = new File(filePath);</code></pre><p>创建文件/文件夹</p><pre class=" language-lang-java"><code class="language-lang-java">file.createNewFile();//文件file.mkdirs();//文件夹</code></pre><p>删除文件</p><pre class=" language-lang-java"><code class="language-lang-java">file.delete();</code></pre><p>递归删除文件夹</p><pre class=" language-lang-java"><code class="language-lang-java">public static void deleteDirectory(String filePath){        File file = new File(filePath);        if(!file.exists()){            return;        }        if(file.isFile()){            file.delete();        }else if(file.isDirectory()){            File[] files = file.listFiles();            for (File myfile : files) {                deleteDirectory(filePath + "/" + myfile.getName());            }            file.delete();        }}</code></pre><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>字节为单位读取，用于二进制文件，如图片、影像、音频</p><pre class=" language-lang-java"><code class="language-lang-java">public static String readFileByBytes(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        StringBuffer content = new StringBuffer();        try {            byte[] temp = new byte[1024];            FileInputStream fileInputStream = new FileInputStream(file);            while(fileInputStream.read(temp) != -1){                content.append(new String(temp));                temp = new byte[1024];            }            fileInputStream.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content.toString();}</code></pre><p>以字符为单位读取文件，用于读文本，数字等类型文件，支持中文</p><pre class=" language-lang-java"><code class="language-lang-java">public static String readFileByChars(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        StringBuffer content = new StringBuffer();        try {            char[] temp = new char[1024];            FileInputStream fileInputStream = new FileInputStream(file);            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "GBK");            while(inputStreamReader.read(temp) != -1){                content.append(new String(temp));                temp = new char[1024];            }            fileInputStream.close();            inputStreamReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content.toString();}</code></pre><p>以行为单位读取文件，用于读面向行的格式化文件</p><pre class=" language-lang-java"><code class="language-lang-java">public static List<String> readFileByLines(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        List<String> content = new ArrayList<String>();        try {            FileInputStream fileInputStream = new FileInputStream(file);            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "GBK");            BufferedReader reader = new BufferedReader(inputStreamReader);            String lineContent = "";            while ((lineContent = reader.readLine()) != null) {                content.add(lineContent);                System.out.println(lineContent);            }            fileInputStream.close();            inputStreamReader.close();            reader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content;}</code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>FileWriter</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByFileWriter(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            FileWriter fw = new FileWriter(filePath);            fw.write(content);            fw.close();        }}</code></pre><p>BufferedOutputStream</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByBufferedOutputStream(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(filePath));            fos.write(content.getBytes("GBK"));            fos.flush();            fos.close();        }}</code></pre><p>FileOutputStream</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByFileOutputStream(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            FileOutputStream fos = new FileOutputStream(filePath);            fos.write(content.getBytes("GBK"));            fos.close();        }}</code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>将基本类型转换为面向对象，类名为Byte，Boolean，Short，Character，Integer，Long，Float，Double。</p><pre class=" language-lang-java"><code class="language-lang-java">String s = "123";int n = Integer.parseInt(s);//将字符串"120"按照十进制转换为int,则结果为120int n = Integer.parseInt("120",10);//将字符串"12"按照十六进制转换为int,则结果为18int n = Integer.parseInt("12",16);//将字符串"ff"按照十六进制转换为int,则结果为255int n = Integer.parseInt("ff",16);int m = 1000;String s = Integer.toString(m);//将int值转换为特定进制的字符串</code></pre><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>不可变性</p><h2 id="可变String"><a href="#可变String" class="headerlink" title="可变String"></a>可变String</h2><p>StringBuffer多线程数据量较大/StringBuilder(效率高，不安全)单线程数据量较大</p><pre class=" language-lang-java"><code class="language-lang-java">public class Test{    public static void main(String args[]){        StringBuffer sBuffer = new StringBuffer("first");        sBuffer.append("second");        System.out.println(sBuffer);          sBuffer.delete(1,3);        System.out.println(sBuffer);         sBuffer.reverse()        System.out.println(sBuffer);     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/2020/09/11/git-shi-yong/"/>
      <url>/2020/09/11/git-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基本使用"><a href="#Git基本使用" class="headerlink" title="Git基本使用"></a>Git基本使用</h1><h2 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h2><h3 id="查看当前项目下的配置"><a href="#查看当前项目下的配置" class="headerlink" title="查看当前项目下的配置"></a>查看当前项目下的配置</h3><pre class=" language-lang-git"><code class="language-lang-git">git config -l  #查看所有配置git config --system -l #查看系统配置git config --global --list #查看用户配置</code></pre><h3 id="配置用户变量"><a href="#配置用户变量" class="headerlink" title="配置用户变量"></a>配置用户变量</h3><pre class=" language-lang-git"><code class="language-lang-git">git config --global user.name "YouTaoBaBa" #配置用户名git config --global user.email 674508620@qq.com #配置用户邮箱</code></pre><h2 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h2><p>用户目录下找.ssh文件夹里找-d_rsa.pub，如果没有，则使用以下命令生成公钥，然后将公钥复制到远程仓库管理(github,gitee,coding等)的ssh配置里</p><pre class=" language-lang-git"><code class="language-lang-git">ssh-keygen -t rsa</code></pre><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><pre class=" language-lang-git"><code class="language-lang-git">git init #本地初始化git clone [url](https或者ssh) #复制远程仓库</code></pre><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><pre class=" language-lang-git"><code class="language-lang-git">git add . #添加所有文件到暂存区</code></pre><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><pre class=" language-lang-git"><code class="language-lang-git">git status</code></pre><h3 id="提交暂存区至本地仓库"><a href="#提交暂存区至本地仓库" class="headerlink" title="提交暂存区至本地仓库"></a>提交暂存区至本地仓库</h3><pre class=" language-lang-git"><code class="language-lang-git">git commit -m "filename"</code></pre><h3 id="提交至远程仓库"><a href="#提交至远程仓库" class="headerlink" title="提交至远程仓库"></a>提交至远程仓库</h3><pre class=" language-lang-git"><code class="language-lang-git">git push (origin master)</code></pre><h3 id="同步远程仓库至本地仓库"><a href="#同步远程仓库至本地仓库" class="headerlink" title="同步远程仓库至本地仓库"></a>同步远程仓库至本地仓库</h3><pre><code>git pull</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在主目录下建立 “.gitignore”文件，文件规则如下：</p><ol><li>忽略文件中的空行和井号开始的行会被忽略</li><li>可以使用linux通配符</li><li>名称最前面有!表示例外规则，不被忽略</li><li>名称前面德文路径分隔符(‘/‘)表示要忽略的文件在此目录下，而子目录的文件不忽略</li><li>如果名称的最后一个是路径分隔符(‘/‘)表示忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)。</li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支</p><pre class=" language-lang-git"><code class="language-lang-git">git branchgit branch -r #查看远程分支</code></pre><p>新建分支dev</p><pre class=" language-lang-git"><code class="language-lang-git">git branch devgit checkout -b dev #新建一个分支并切换到这个分支</code></pre><p>切换分支</p><pre class=" language-lang-git"><code class="language-lang-git">git checkout master</code></pre><p>删除分支dev</p><pre class=" language-lang-git"><code class="language-lang-git">git branch -d dev</code></pre><p>合并指定分支到当前分支</p><pre class=" language-lang-git"><code class="language-lang-git">git merge [branch]</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建Hexo博客</title>
      <link href="/2020/09/10/cong-ling-kai-shi-da-jian-hexo-bo-ke/"/>
      <url>/2020/09/10/cong-ling-kai-shi-da-jian-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   准备工作:安装nodejs, 安装git, 配置github的SSH</p></blockquote><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>进入<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>下载稳定版本，一路点击next，安装完成后，打开cmd，输入命令<code>node -v</code>和<code>npm -v</code>，如果显示版本号，安装成功</p><p><img src="https://s1.ax1x.com/2020/09/10/wJYoXq.png" alt="wJYoXq.png"></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>进入<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>下载对应的安装文件，下载完成之后，设置用户名和邮箱，再配置Github账户的SSH</p><p>使用<code>git config --global user.name &quot;username&quot;</code>设置用户名，注意username是自己的GitHub用户名，邮箱是GitHub邮箱</p><p><img src="https://s1.ax1x.com/2020/09/10/wJt4UO.png" alt="wJt4UO.png"></p><p>使用<code>git config --global user.email &quot;email&quot;</code>设置邮箱，注意eamil指的是自己的GitHub绑定的邮箱</p><p><img src="https://s1.ax1x.com/2020/09/10/wJtT8H.png" alt="wJtT8H.png"></p><h3 id="配置github的SSH"><a href="#配置github的SSH" class="headerlink" title="配置github的SSH"></a>配置github的SSH</h3><p>进入到家目录的<code>.ssh</code>文件夹，输入<code>ssh-keygen -t rsa -C &quot;eamil&quot;</code>，这里的email是自己的GitHub绑定的邮箱地址，连续三个回车。在当前用户目录下的.ssh文件夹下，产生了两个文件，一个是公钥文件，一个是私钥文件。</p><p><img src="https://s1.ax1x.com/2020/09/10/wJNBLt.png" alt="wJNBLt.png"></p><p>复制公钥文件的内容，到GitHub网站，在<code>Settings</code>页面左边的<code>SSH and GPG keys</code>部分，新建一个SSH keys，粘贴刚刚复制过来的内容</p><p><img src="https://s1.ax1x.com/2020/09/10/wJNgJg.png" alt="wJNgJg.png"></p><p>再到Git中，输入<code>ssh -T git@github.com</code>，如果出现<strong>Hi，username</strong>，那么表明本地成功连接了GitHub</p><p><a href="https://imgchr.com/i/wJN4Lq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/10/wJN4Lq.png" alt="wJN4Lq.png"></a></p><blockquote><p>  新建仓库存放博客内容，并且安装和美化Hexo</p></blockquote><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>新建一个项目， 名称为<code>账户名.github.io</code>，勾选<strong>Initialize this repository with a README</strong></p><p><img src="https://s1.ax1x.com/2020/09/10/wJUGXn.png" alt="wJUGXn.png"></p><p>点击项目的Settings,下拉到<strong>GitHub Pages</strong>部分，Source下拉框的选项如果是<code>None</code>，那么要改为<code>master branch</code>，点击<code>save</code>按钮保存，上方会显示一个网址，这个就是被部署到外网的网址，能够通过外网访问</p><p><img src="https://s1.ax1x.com/2020/09/10/wJUwhF.png" alt="wJUwhF.png"></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在本地创建一个文件夹，作为博客系统的根目录，进入到这个目录</p><p>输入<code>npm install hexo -g</code>，开始安装Hexo</p><p>输入<code>hexo -v</code>，检查hexo是否安装成功</p><p>输入<code>hexo init</code>，初始化该文件夹</p><p>输入<code>npm install</code>，安装所需要的组件</p><p>输入<code>hexo g</code>，g是generate的缩写</p><p>输入<code>hexo s</code>，s是start的缩写，表明开启服务器，此时浏览器打开该网址<code>localhost:4000</code></p><p>如果出现下图，那么Hexo就搭建成功了</p><p><img src="https://s1.ax1x.com/2020/09/10/wJULAf.png" alt="wJULAf.png"></p><p>目前只能本地访问到，下面配置外网访问</p><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>配置deployment，在项目文件夹中，找到配置文件<strong>_config.yml</strong>，修改repo的值，增加<strong>branch</strong>的值为<strong>master</strong></p><p><img src="https://s1.ax1x.com/2020/09/10/wJaPH0.png" alt="wJaPH0.png"></p><p>repo的值是GitHub项目右下角，<strong>Use SSH</strong>的，以<strong>git</strong>结尾的一个链接， 默认是<strong>Use HTTPS</strong>，使用<strong>Use SSH</strong>选项就能看到以<strong>git</strong>结尾的链接。复制这个以<strong>git</strong>结尾的链接，粘贴到配置文件<strong>_config.yml</strong>，修改repo的值</p><p><img src="https://s1.ax1x.com/2020/09/10/wJakNT.png" alt="wJakNT.png"></p><p>cmd进入博客根目录，安装一个扩展，<code>npm install hexo-deployer-git --save</code></p><p>新建一片博客，在cmd进入根目录后，用<code>hexo new post &quot;文章名&quot;</code></p><p>输入命令<code>hexo g &amp;&amp; hexo d</code>，然后再输入Github Pages的网址就能够访问了</p><h3 id="美化主题"><a href="#美化主题" class="headerlink" title="美化主题"></a>美化主题</h3><p>默认的主题样式一般，选择更好看的主题matery</p><p>进入到<code>themes</code>文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><p>修改 <code>_config.yml</code> 的 <code>url</code> 的值为网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</p><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-bash"><code class="language-lang-bash">search:  path: search.xml  field: post</code></pre><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><pre class=" language-lang-bash"><code class="language-lang-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-lang-bash"><code class="language-lang-bash">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/09/10/markdown-ji-ben-yu-fa/"/>
      <url>/2020/09/10/markdown-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><h3 id="标题级数-’-’个数"><a href="#标题级数-’-’个数" class="headerlink" title="标题级数=’#’个数"></a>标题级数=’#’个数</h3><p>字体格式<br><strong>粗体</strong><br><em>斜体</em><br><del>废弃线</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>油桃牛逼</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://coding-pages-bucket-3473233-7944306-346-307103-1302308732.cos-website.ap-hongkong.myqcloud.com/medias/featureimages/12.jpg" alt="截图"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://coding-pages-bucket-3473233-7944306-346-307103-1302308732.cos-website.ap-hongkong.myqcloud.com/" target="_blank" rel="noopener">跳转到油桃的博客首页</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>A</li><li>B</li><li>C</li></ol><ul><li>A</li><li>B</li><li>C</li></ul><div class="table-container"><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1997.7</td></tr></tbody></table></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-lang-python"><code class="language-lang-python">import pdbpdb.set_trace()</code></pre><script type="math/tex; mode=display">\hat{\pi}_{q_{i}}=\frac{count(q_{i}^{1})}{count(o_{1})}, s.t.\sum_{i} \pi_{q_{i}}=1</script>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog书写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/09/10/hello-world/"/>
      <url>/2020/09/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一次配置完成Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
