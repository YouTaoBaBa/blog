<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DSRL</title>
      <link href="/2020/11/26/dsrl/"/>
      <url>/2020/11/26/dsrl/</url>
      
        <content type="html"><![CDATA[<h1 id="Dual-Super-Resolution-Learning-for-Semantic-Segmentation"><a href="#Dual-Super-Resolution-Learning-for-Semantic-Segmentation" class="headerlink" title="Dual Super-Resolution Learning for Semantic Segmentation"></a>Dual Super-Resolution Learning for Semantic Segmentation</h1><p><a href="https://openaccess.thecvf.com/content_CVPR_2020/html/Wang_Dual_Super-Resolution_Learning_for_Semantic_Segmentation_CVPR_2020_paper.html" target="_blank" rel="noopener">论文链接：https://openaccess.thecvf.com/content_CVPR_2020/html/Wang_Dual_Super-Resolution_Learning_for_Semantic_Segmentation_CVPR_2020_paper.html</a> </p><p><a href="https://github.com/wanglixilinx/DSRL" target="_blank" rel="noopener">代码链接： https://github.com/wanglixilinx/DSRL</a> </p><p><a href="https://blog.csdn.net/weixin_42096202/article/details/106843395" target="_blank" rel="noopener">参考博客：https://blog.csdn.net/weixin_42096202/article/details/106843395</a></p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>提出了一个双超分辨率学习框架来保持高分辨率的表示，可以在保持推理速度的同时提高性能。</li><li>验证了DSRL框架的通用性，它可以很容易地扩展到其他需要高分辨率表示的任务，如人体姿态估计。</li><li>证明了该方法在语义分割和人体姿态估计方面的有效性。在同样的计算量下，能提升≥2%的精度，在同等表现下减少FLOPs。</li></ul><h2 id="Proposed-Approach"><a href="#Proposed-Approach" class="headerlink" title="Proposed Approach"></a>Proposed Approach</h2><p><img src="image-20201126195835201.png" alt="图2"></p><p>双分支超分辨率学习（DSRL）结构如上图所示。可以看出，两个分支网络分别为SSSR与SISR，<strong>这俩共享Encoder结构</strong>。然后使用各自的Decoder分别输出语义分割的预测结果和图像超分辨率结果。FA主要用于增强两个分支特征的一致性。接下来将具体介绍体系结构的三个部分：<br>（a）语义分割超分辨率（SSSR）；<br>（b）单图像超分辨率（SISR）；<br>（c）特征相似度（FA）模块。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分辨率语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPN</title>
      <link href="/2020/11/25/ppn/"/>
      <url>/2020/11/25/ppn/</url>
      
        <content type="html"><![CDATA[<h1 id="Patch-Proposal-Network-for-Fast-Semantic-Segmentation-of-High-Resolution-Images"><a href="#Patch-Proposal-Network-for-Fast-Semantic-Segmentation-of-High-Resolution-Images" class="headerlink" title="Patch Proposal Network for Fast Semantic Segmentation of High-Resolution Images"></a>Patch Proposal Network for Fast Semantic Segmentation of High-Resolution Images</h1><p><a href="https://ojs.aaai.org//index.php/AAAI/article/view/6926" target="_blank" rel="noopener">论文地址：https://ojs.aaai.org//index.php/AAAI/article/view/6926</a> </p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>PPN的目的是从普通的patches中选出重要的patch，它是一个具有较好评判准则的分类网络，他能够减轻训练负担并改善分割的结果。</li><li>对于超分任务，该篇研究将PPN嵌入全局细化网络（GRNet），并使用PPN来指导全局分支和细化分支之间的协作。</li><li>与最先进的方法相比，文章提出的GRNet在3个公开的高分辨率数据集上取得了最好的性能:DeepGlobe、ISIC和CRAG。特别是，该篇工作的方法在DeepGlobe上使用GPU实现了12.9帧/秒的帧率，因此，无论在速度还是在精度上，它都是一种实用的分割方法。</li><li>PPN具有良好的泛化能力。它可以很容易地直接集成到其他流行的语义分割框架中。PPN提高了baseline语义分割网络的分割性能。</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>对多尺度上下文信息的融合，可以让我们得到了较好的分割效果。RefineNet增加了一个多路径细分块，在不同的层次上递归利用多尺度特征。特征金字塔网络(Feature Pyramid Network,FPN) 利用多尺度语义信息，通过自上而下的不同层次融合机制实现预测。</p><p>此外，上下文聚合在分割方法中起着重要的作用。DeepLab采用了扩张型卷积和空洞空间金字塔池化模块（atrous spatial pyramid pooling module）来帮助扩展感受域，有利于更好地将全局上下文聚合为细粒度特征。PSPNet采用金字塔汇聚模块，将不同区域的上下文信息聚合起来，提高了捕获全局上下文的能力。</p><p>此外，出于实时性和低延迟的目的，追求快速或实时的语义分割模型越来越受到人们的关注。ICNet 采用级联特征融合机制，利用低分辨率信息和高分辨率图像的细节来细化分割预测。BiSeNet构建了两条路径，一条是负责获取空间信息的空间路径，另一条是实现较大接受场的上下文路径，然后利用特征融合模块将两条路径的输出进行整合。虽然这些实时分割网络具有较低的计算复杂度和内存消耗，但它们的分割精度远远低于其他网络。</p><h2 id="Proposal-Method"><a href="#Proposal-Method" class="headerlink" title="Proposal Method"></a>Proposal Method</h2><h3 id="The-Architecture-of-GRNet"><a href="#The-Architecture-of-GRNet" class="headerlink" title="The Architecture of GRNet"></a>The Architecture of GRNet</h3><p>下图显示了GRNet的架构。GRNet包含三个组件:全局分支(g分支)、PPN和细化分支(r分支)。将下采样图像输入G-branch和PPN。利用G-branch生成下行采样图像的初步全局分割特征。PPN选择重要的补丁。然后由G-branch和PPN引导R-branch对所选patch的分割进行细化，即特征提取和细化。然后，融合全局层次特征和细化的局部特征生成最终的分割。下面我们将详细介绍PPN的运行机制、特征提取和细化以及特征融合。</p><p><img src="image-20201125173639798.png" alt="图2 GRNet的架构。GRNet包含三个组件:G-branch、PPN和R-branch。首先对下采样图像进行G-branch和PPN处理。然后用结果指导R-branch对分割进行细化。然后将细化后的分割结果与特征融合块中全局分支的输出进行融合。最后生成分割结果。"></p><h4 id="PPN"><a href="#PPN" class="headerlink" title="PPN"></a>PPN</h4><p>PPN是一个独立的网络，作为一个选择器。在测试阶段，PPN在没有监督的情况下进行选择。因此，PPN必须在训练阶段学习选择规则。受到老师教学的启发，如果老师想要提高小组的平均成绩，一个更简单的方法是提高低于平均成绩的学生的成绩。因此我们采用类似的判别选择规则来指导PPN进行patch选择。当遇到当前特征的分割得分$I_{c}$低于全局平均分数$I_{t}$的时候，该特征块将会被选择并记录为1，具体公式如下所示。这里，以G-branch中得到的均值对并集的交(mIoU)作为分割分数的度量。</p><script type="math/tex; mode=display">K=\begin{cases}1& {I_{c}<I_{t}}\\0& otherwise\end{cases}</script><p>先将H×W超分图$I$下采样为$I_{g}$，并平等地划分成N个不重叠的patches，然后将$I_g$喂进全局分支获得特征$F^G$,然后用划分$I_g$的方法去划分$F^G$。</p><p>PPN是一个分类网络，其体系结构如图3所示。将下采样图像$I_g$送入PPN的主干中，提取深层特征$F^B$，平铺成特征patch $\{ {F^B_i}\}^N_{i=1}$。然后通过平均池化层对$F^B$和$F^B_i$进行处理，再通过全连接层得到全局得分$G_{score}$和patch得分$P_{score}$。然后将$G_{score}$与各$P_{score}$的差值输入sigmoid函数进行预测，预测结果形成flag map，其中值1表示预测概率≥0.5，值0表示预测概率&lt;0.5。我们将二进制交叉熵(BCE)损失用于PPN，这是训练一个二元分类网络的标准实践。</p><p><img src="image-20201125182517527.png" alt="图3 PPN框架。将整个初步特征和特征块依次送入平均池化层、全连接层和sigmoid函数中，得到flag map。减号表示G和P之间的元素间的减法。"></p><h4 id="Feature-Extraction-and-Refinement"><a href="#Feature-Extraction-and-Refinement" class="headerlink" title="Feature Extraction and Refinement"></a>Feature Extraction and Refinement</h4><p>根据PPN的flag map，自适应地从G-branch中选取特征patch$F^G_i$和对应位置的原始图像$I$的patch$P_i$，使G-branch和R-branch协同工作。为了细化patch分割，首先将$F^G_i$放大到$P_i$的大小。我们在放大后的$F^G_i$上执行类似于(Yu et al. 2018b)的显著性操作，并将结果与$P_i$进行元素逐点相乘，得到显著性图像patch，并将显著性图像patch送入R-branch。分支输出改进的patch分割$F^R_i$。</p><h4 id="Feature-Fusion"><a href="#Feature-Fusion" class="headerlink" title="Feature Fusion"></a>Feature Fusion</h4><p>为了准备一个简单而有效的融合机制来更好地融合来自G-Branch全局特征$F^G$和选中的来自R-Branch的局部特征,选中的地方特色从R-branch$F^R_i$,我们首先重塑特性映射$F^E$(初始化为0),将其变为与$F^G$一样的大小并均匀划分为$\{F_1^E,F_2^E,……,F_i^E,…,F_N^E\}$。如果第i个patch被PPN选中，那么改进后的特征$F^R_i$将会取代FE中的对应特征$F^E_i$。特别的是，在$F^G$中，选择的patch应与对应的patch融合，未选择的patch保持不变。最后,重建的$F$与$F^G$,然后连接结果送入聚合层包含三个卷积层:(3,3,256),(3,3,256),(1,1,Nc),其中(k, k, s)意味着卷积核是k×k×s，Nc是类别数量。</p><h4 id="Overall-Loss-Function"><a href="#Overall-Loss-Function" class="headerlink" title="Overall Loss Function"></a>Overall Loss Function</h4><script type="math/tex; mode=display">L=L_g+L_R+L_A</script><script type="math/tex; mode=display">\mathcal{L}_{\mathcal{G}}=\left\{\begin{array}{ll}-\left(1-y_{g}^{\prime}\right)^{\gamma} \log y_{g^{\prime}}^{\prime}, & y_{g}=1 \\ -y_{g}^{\prime \gamma} \log \left(1-y_{g}^{\prime}\right), & y_{g}=0\end{array}\right.</script><script type="math/tex; mode=display">\mathcal{L}_{\mathcal{R}}=\left\{\begin{array}{ll}-\left(1-y_{r}^{\prime}\right)^{\gamma} \log y_{r^{\prime}}^{\prime}, & y_{r}=1 \\ -y_{r}^{\prime \gamma} \log \left(1-y_{r}^{\prime}\right), & y_{r}=0\end{array}\right.</script><script type="math/tex; mode=display">\mathcal{L}_{\mathcal{A}}=\left\{\begin{array}{ll}-\left(1-y_{a}^{\prime}\right)^{\gamma} \log y_{a}^{\prime}, & y_{a}=1 \\ -y_{a}^{\prime \gamma} \log \left(1-y_{a}^{\prime}\right), & y_{a}=0\end{array}\right.</script><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>采用交替优化的3步训练方案。这里，将除PPN之外的网络定义为主体，包括G-branch、R-branch和聚合层，并将PPN作为选择器。G-branch使用以ResNet50 (He et al. 2016)为主干的FPN (Lin et al. 2017b)，R-branch使用以ResNet18 为主干的FPN。PPN使用没有最后一个残块的ResNet18 作为骨干。首先，我们微调训练G-branch来完成端到端全局分割任务。其次，我们在g分支输出的指导下对PPN进行训练。G-branch和PPN是两个独立的网络。最后，我们在R-branch中对分割进行了细化。在聚合层PPN的指导下，将细化结果与G-branch的输出进行融合。固定PPN调整主体。迭代进行交替训练，直到达到设定的迭代次数。</p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p><strong>DeepGlobe</strong>：DeepGlobe (Demir et al. 2018)是一个聚焦于农村地区的高质量卫星数据集，提供了7类803幅图像，分辨率为2448×2448像素。我们将数据集随机分为训练集、验证集和测试集，分别为455、206和142张图像。特别地，七个类中的对象命名为unknown，在我们的实验中没有讨论。</p><p><strong>ISIC</strong>：ISIC (schandl, Rosendahl, Kittler 2018;Codella et al. 2018)是一个用于色素皮肤病变的超分辨率医学数据集，其训练集包含2077张图像，验证集包含260张图像，测试集包含259张图像。ISIC的平均分辨率高达9 m，最大的图像尺寸为6748×4499。密集的注释包括两类:病变区域和背景。但由于背景比例较大，我们只选取病变区域进行评估。</p><p><strong>CRAG</strong>：CRAG (Graham et al. 2019;Awan et al. 2017)是一个HRI数据集，包括两类并显示不同分化的腺形态。将CRAG数据集分为训练集和测试集，分别包含173和40张图像。平均尺寸1512×1516。</p><p><strong>Cityscapes</strong>：Cityscapes (Cordts et al. 2016)是一种街景数据集，通常被常用的语义分割方法用于评价。其中包含3475张大小为2048×1024的精细注释图像，其中2975张用于训练，其余用于验证。有19个预定义的语义类，这19个类之外的对象在训练和验证阶段都将被忽略。</p><h3 id="Ablation-Studies"><a href="#Ablation-Studies" class="headerlink" title="Ablation Studies"></a>Ablation Studies</h3><p><img src="image-20201126135712278.png" alt="图4"></p><p><img src="image-20201126135737882.png" alt="图5"></p><p><img src="image-20201126135853091.png" alt="图6"></p><p><img src="image-20201126135804722.png" alt="表1"></p><p><img src="image-20201126135935481.png" alt="表2"></p><h3 id="Comparisons-with-state-of-the-art-methods"><a href="#Comparisons-with-state-of-the-art-methods" class="headerlink" title="Comparisons with state-of-the-art methods"></a>Comparisons with state-of-the-art methods</h3><p><img src="image-20201126140055529.png" alt="图7"></p><p><img src="image-20201126143716387.png" alt="表3"></p><p><img src="image-20201126140327304.png" alt="表4"></p><p><img src="image-20201126140348850.png" alt="表5"></p><p><img src="image-20201126140407105.png" alt="表6"></p><h3 id="The-generalization-of-PPN"><a href="#The-generalization-of-PPN" class="headerlink" title="The generalization of PPN"></a>The generalization of PPN</h3><p><img src="image-20201126140829464.png" alt="表7"></p><p><img src="image-20201126140854740.png" alt="图8"></p><p><img src="image-20201126140931203.png" alt="图9"></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这项工作提出PPN，在超分高分图像语义分割任务上更好地权衡分割精度，推理速度和内存使用。PPN嵌入到全局-局部框架中，选择重要的patch，并进一步细化。在DeepGlobe、ISIC和CRAG上的实验结果表明，该方法取得了最佳的综合性能。此外，PPN还可以嵌入到其他语义分割框架中，实验结果表明，PPN具有良好的泛化能力。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分辨率语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GLNet</title>
      <link href="/2020/11/24/glnet/"/>
      <url>/2020/11/24/glnet/</url>
      
        <content type="html"><![CDATA[<h1 id="Collaborative-global-local-networks-for-memory-efficient-segmentation-of-ultra-high-resolution-images"><a href="#Collaborative-global-local-networks-for-memory-efficient-segmentation-of-ultra-high-resolution-images" class="headerlink" title="Collaborative global-local networks for memory-efficient segmentation of ultra-high resolution images"></a>Collaborative global-local networks for memory-efficient segmentation of ultra-high resolution images</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li><p>现有方法在超分辨率图像上的处理都是下采样或者切块，要不就损失局部信息，要不就损失上下文信息</p></li><li><p>显存占用对于语义分割任务产生了限制，现有部分需要在显存占用和精度之间做取舍</p></li><li><p>单独的全局网络或者局部网络效果都不好</p></li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>首次提出memory-efficient（内存/显存高效）的超分图分割方法，不仅准确率高，显存占用也小。</li><li>能够有效使用全局上下文信息和局部精细结构，分割精度高，这两个模块都是必不可少的。</li><li>针对超分图分割的类别不平衡问题，提出由粗到细的GLNet算法，进一步提高了性能。</li></ul><p>GLNet通过全局分支和局部分支，分别处理下采样的全局图和裁剪的局部图。它们通过feature map跨层共享，相互作用和调节。在准确率和显存占用上取得了很好的平衡。为了进一步解决类别不平衡问题，当分割较小的前景区时，这篇文章提供了GLNet的变体，其中全局分支提供了额外的边界框（bounding box）。它的设计使得能够综合使用全局信息和局部信息，确保精准地分割。同时极大地减少了GPU的使用，因为送到网络的是下采样的全局图和裁剪的局部图，原来整张的高清图是不会送进去的。</p><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h3 id="语义分割的质量和精度"><a href="#语义分割的质量和精度" class="headerlink" title="语义分割的质量和精度"></a>语义分割的质量和精度</h3><p>FCN是第一个高质量分割的CNN结构；U-net使用encoder-decoder结构，使用跳级连接将低级特征连接到高级特征，相似结构还有DeconvNet和SegNet；DeepLab使用膨胀卷积（也叫空洞卷积）扩大感受野，条件随机场用来建模空间关系。但是这些方法的显存占用都很高。</p><p>随着语义分割在很多实时/低延迟 任务（比如自动驾驶）中越来越重要，高效快速的分割获得越来越多的关注。ENet在早期使用下采样，使用非对称的encoder-decoder结构减少浮点运算；ICNet将多分辨率的分支的feature map在适当的标签下级联处理，并进行模型压缩。然而这些方法没有针对超分辨率图像，实验表明没有取得效率和精度的平衡（主要是精度不够）。</p><h3 id="多尺度和上下文聚合"><a href="#多尺度和上下文聚合" class="headerlink" title="多尺度和上下文聚合"></a>多尺度和上下文聚合</h3><p>多尺度是集成高层和底层特征捕获不同粒度信息的模式，在分割上很有效。在RefineNet中，通过上采样低分辨率特征，构造多路径精化块来结合多尺度特征。文献32采用拉普拉斯金字塔结构利用高层特征来细化低分辨率图构造的边界。FPN逐步上采样不同尺度的特征图，并且自上而下地聚合它们。分级自动缩放网络（HAZN）采用两步自动缩放策略将粗级的边界框和预测分数送到细级。</p><p>上下文聚合在编码局部邻域空间甚至非局部信息方面也起着关键作用。ParseNet采用全局池化聚合不同级别的场景上下文。DeepLab中的空洞卷积和ASPP（空间金字塔池化）在不丢失feature map的情况下扩大感受野，从而将全局上下文聚合到局部信息中，PSPNet中的金字塔池实现了类似的效果。在ContextNet，BiSeNet和GUN中，深/浅分支被结合到全局上下文和高分辨率细节上。文献37把上下文信息看作是RNN建模的长期依存关系。需要注意在GLNet中，在输入级（全局/局部分支）和特征级都采用了上下文聚合。</p><h3 id="超分辨率分割数据集"><a href="#超分辨率分割数据集" class="headerlink" title="超分辨率分割数据集"></a>超分辨率分割数据集</h3><p>DeepGlobe陆地覆盖分类数据集是第一个提供在农村地区高分辨率亚米级卫星图像的公开benchmark。提供了7类像素级ground truth的mask：城市，农业，牧场，森林，水，荒地，和未知。包含1146张标注的卫星图，大小都是2448 ×× 2448，比以往的陆地覆盖分类数据集有更高的分辨率和更大的挑战性。</p><p>ISIC收集大量的皮肤镜图像。它的子集ISIC Lesion Boundary Segmentation由2594张皮肤癌患者筛查的样本图像组成，所有图像都标注了ground truth的二值mask，指出了原发皮肤损伤的位置。超过64%的图像有超分辨率，最大的图像是6682 ×× 4401像素。</p><p>Inria Aerial数据集涵盖了不同城市景观，从人口稠密的都市区到阿尔卑斯度假胜地。提供了180张5000 ×× 5000像素的图片，都是二值mask，表示有建筑区和没有建筑区，与DeepGlobe不同的是，它将训练测试集按城市分类，而不是随机分类。</p><h2 id="协同全局-局部网络"><a href="#协同全局-局部网络" class="headerlink" title="协同全局-局部网络"></a>协同全局-局部网络</h2><h3 id="GLNet结构"><a href="#GLNet结构" class="headerlink" title="GLNet结构"></a>GLNet结构</h3><p>N张超分图像，图像片段$\mathcal{D}=\{(\boldsymbol{I}_{i}, \boldsymbol{S}_{i})\}_{i=1}^{N}$，满足$\boldsymbol{I}_{i}, \boldsymbol{S}_{i} \in \mathbb{R}^{H \times W}$，全局分支获得下采样低分辨率的图$g$并且$\mathcal{D}^{\mathrm{lr}}=\{(\boldsymbol{I}_{i}^{\mathrm{lr}}, \boldsymbol{S}_{i}^{\mathrm{lr}})\}_{i=1}^{N}$，局部分支$L$对于$\mathcal{D}$</p><p><img src="image-20201124200945752.png" alt="全局分支和局部分支分别取下采样图像和裁剪图像。深度特征共享和特征正规化加强了全局-局部协作。最终的分割是通过聚合两个分支的高级特征图生成的。"></p><p><img src="image-20201124202556019.png" alt="全局和局部分支之间的深度特征共享。在每一层中，具有全局信息的特征图和具有局部精细结构的特征图都被双向地整合在一起，从而形成一个完全基于小块的深度全局-局部协作。聚合结果的主要损失和两个分支的两个辅助损失构成了文章的优化目标。"></p><p>在分割过程中，各个分支的各层特征与另外的分支共享，然后通过分支层对两组高层特征图聚合生成最终的分割mask。为了约束两个分支，稳定训练过程，局部分支训练采用<strong>弱耦合正则化</strong>（weakly-coupled）。</p><h4 id="深度特征图共享"><a href="#深度特征图共享" class="headerlink" title="深度特征图共享"></a>深度特征图共享</h4><p>为了与local分支协作，需要将global分支中local patch对应空间位置裁剪，然后上采样到和local分支 feature map相同的大小，然后被同一层的local分支的feature map concatenate，通过对称的方式，local分支的feature map也是这么收集的。首先对local的feature map下采样，匹配从原图裁剪对应位置的patch，然后合并在一起（与局部patch被裁剪的顺序相同），形成完整的特征图，它的大小与全局分支的feature map相同。在送到下一层之前，这些局部特征也被concat到全局特征中。</p><p>图5展示了这个过程，除了最后一层外，它是layer-wise（逐层）的。共享的方向可以是单向的（G→L）也可以是双向（G⇄L）的。每一层中，全局上下文特征和局部精细特征相互融合借鉴。</p><h4 id="带正则化的分支聚合"><a href="#带正则化的分支聚合" class="headerlink" title="带正则化的分支聚合"></a>带正则化的分支聚合</h4><p>两个分支的聚合是通过聚合层$f_{agg}$，它由一个3 × 3的卷积核的卷积层实现。它从local分支的$L_{th}$层$\hat{X}_{L}^{\mathrm{Loc}}$和对应的global分支的$\hat{\boldsymbol{X}}_{L}^{\mathrm{Glb}}$，通过channel拼接（concat），输出层$f_{agg}$得到最后的分割结果$\hat{S}^{\mathrm{Agg}}$。另外为了实施$\hat{S}^{\mathrm{Agg}}$的主要分割loss（main loss），采用了两种辅助的loss，为了强制局部分支的输出$\hat{S}^{\mathrm{Loc}}$和global分支的输出$\hat{S}^{\mathrm{Glb}}$靠近它们的分割map（local patch/global downsmaple），能够让训练过程更稳定。</p><p>在实践中发现local分支容易过拟合local detail（局部细节），从而overriding在global分支的学习，为了避免local分支学习速度比global分支快，在两个分支最后一层特征映射之间添加了弱耦合正则化（weakly-coupled）。具体的说是用2范数$\lambda|\hat{\boldsymbol{X}}_{L}^{\mathrm{Loc}}-\hat{\boldsymbol{X}}_{L}^{\mathrm{Glb}}|_{2}$，防止$\hat{\boldsymbol{X}}_{L}^{\mathrm{Loc}}$与$\hat{\boldsymbol{X}}_{L}^{\mathrm{Glb}}$之间有太大的变化，根据经验，λλ固定为0.15。这种正则化主要是让local分支的训练变慢，与global分支的学习同步，它只更新local分支的参数。</p><h4 id="由粗到细的GLNet"><a href="#由粗到细的GLNet" class="headerlink" title="由粗到细的GLNet"></a>由粗到细的GLNet</h4><p>分割是为了分离前景与背景，（比如二值mask），前景通常在超分图中占据很小的空间。这种类别不平衡会严重影响性能。以ISIC数据集为例，99%的图像背景比前景多，超过60%的图像前景像素比例少于20%（图8中的蓝条），</p><p><img src="image-20201124205826175.png" alt="ISIC 2018数据集中前景与背景像素比率的直方图。蓝色条表示global branch边界框细化前的比率，红色条表示细化后的比率，更加平衡。(2)粗到细分割的视觉结果。经过细化(从(b)到(e))， GLNet能够捕获更精确的边界。"></p><p>很多local patch只包含背景，这会导致梯度不正常。</p><p><img src="image-20201124210252976.png" alt="两级分割。全局分支做粗分割，局部分支做细分割，只处理边界盒前端中心区域。"></p><p>为了缓解类别不平衡，提出GLNet由粗到细的两阶段变体（如图6）。首先用全局分支对下采样的图像进行粗分割，然后为前景区创建一个边界框（动态调整边界框大小，以便边界区域前背景比例约为1，有助于第二步的类别平衡）。然后将原图的边界前景区送到local分支精细分割。</p><p>与并行的全局-局部分支不同，这种由粗到细的GLNet是两个分支的序列组合，在边界框细化过程中，只有边界框类的feature map才会由全局分支共享到局部分支，然后共享回来。</p><p>所有边界框之外的区域都会预测为背景。所以由粗到细的GLNet通过只选择细尺度处理 而降低了计算成本（因为粗尺度直接不考虑了）。</p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>在DeepGlobe，Inria Aerial数据集评估GLNet表现，在ISIC数据集上评估由粗到细的GLNet的表现。</p><h3 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h3><p>采用带有ResNet50的FPN（特征金字塔）作为backbone。深度特征共享策略在自底向上阶段应用于ResNet50的conv2到conv5 block，在自顶向下和smoothing阶段应用于FPN中。对于FPN中最后横向拼接阶段，采用特征图正则化，聚合到最终的分割结果中。</p><p>为了简单起见，下采样的全局图和裁剪的局部patch大小相同，都为500 ×× 500像素，相邻的patch有50像素的重叠避免卷积层边界消失。使用γ=6γ=6的focal loss作为main loss和两个辅助loss。main loss和辅助loss都为1.0，特征图正则化项的λλ设为0.15。</p><p>为了测量模型的GPU占用，使用命令行工具<code>gpustat</code>，<code>minibatch</code>大小为1，避免计算任何梯度。训练和测试只用一张卡。</p><p>用Pytorch实现，优化器Adam($\beta_1=0.9，\beta_2=0.999$)global分支学习率1e-4，local分支学习率 2e−5，训练minibatch为6。</p><h4 id="DeepGlobe"><a href="#DeepGlobe" class="headerlink" title="DeepGlobe"></a>DeepGlobe</h4><p>803张超分图，像素都为2448 ×× 2448，随机划分训练验证测试为455，207，142张。包含7个类别，有1个类别是未知。</p><h5 id="从浅到深的特征图共享"><a href="#从浅到深的特征图共享" class="headerlink" title="从浅到深的特征图共享"></a>从浅到深的特征图共享</h5><p>为了评估global-local的策略，逐步将模型的特征图共享从浅层到深层，对于下采样的全局图或者单独的局部图，每个分支的平均交并比分别只能达到57.3%和66.4%</p><p><img src="image-20201124211157127.png" alt="表2"></p><p>通过两个分支高层特征的聚合以及正则化，mIoU可以到70.3%，当只共享global的一层到local时，聚合结果增加了0.2%，当所有层都共享时，mIoU到了70.9%，如果是双向共享，mIoU到了71.6%。</p><p>消融实验表明通过深度共享，正则化和聚合策略，全局分支和局部分支能够有效地协同，即使用双向共享，显存占用也只从1189MB略微增加到1865MB。</p><p>图7放大（a），（b）可视化改进的效果。全局结果（图7（3））有网状伪影，局部结果（图7（4））有不准确的边界，从聚合，浅层共享到深度共享，显著观察到误分类和不准确边界的情况明显减少。</p><p><img src="image-20201124211256636.png" alt="图7"></p><h5 id="准确性和显存占用比较"><a href="#准确性和显存占用比较" class="headerlink" title="准确性和显存占用比较"></a>准确性和显存占用比较</h5><p>使用全局图和局部图进行训练和推理可能会产生不同的结果，主要是模型感受野，卷积核大小和填充策略不同，这使得训练推理有不同的选择，因此在消融实验中仔细比较了两种方法训练的模型。对一个模型训练和测试两次，然后选择最佳结果。</p><p><strong>固定图像/patch大小的粗略比较</strong>（所有模型都使用500×500×500像素）</p><p>表3展示了所有模型全局推理下的最高mIoU，但是都占用了很多显存。在基于patch的推理中显存下降了，但是准确度也大幅度下降，只有GLNet实现了mIoU和显存占用的平衡，在图1（a）中画出了每种方法最佳的mIoU。</p><p><img src="image-20201124211450988.png" alt="表3"></p><p><strong>深入对比不同图像/patch大小</strong></p><p>选择FCN和ICNet对不同图像/patch大小深入比较，因为它们分别具有较高的mIoU和较小的显存占用。在图1（b）和（c）中绘制了消融实验的细节。对于FCN和ICNet，精度更高因为着显存占用大，反之也是，这证明了经典模型无法平衡效率和精度。</p><h4 id="ISIC"><a href="#ISIC" class="headerlink" title="ISIC"></a>ISIC</h4><p>ISIC皮肤损害边界分割挑战数据集包含2596超分辨率图，随机切分训练，验证测试为2077， 260， 259张图。</p><h5 id="由粗到细的分割"><a href="#由粗到细的分割" class="headerlink" title="由粗到细的分割"></a>由粗到细的分割</h5><p>在严重不平衡的ISIC数据集上，global和local分支分别只能实现72.7%和48.5%的mIoU，当使用由粗到细的策略时，可以清楚看到更加平衡的前景背景比例（图8（1）中的红条）。</p><p>通过裁剪前景边界框，local分支只在更小的类别平衡的图像上训练，默认将裁掉的边界外区域作为背景。在类别平衡的图像总共，<strong>G→L</strong>的mIoU是73.9%，<strong>G⇄L</strong>的mIoU是75.2%，这种情况下，全局分支使用更加精确的全局上下文信息，因为对裁剪更小的图像进行下采样，丢失的信息会更少。由粗到细的方法表明它能较好地捕获上下文信息，解决类别不平衡问题。表4中是消融实验，图8（2）是可视化结果。</p><p><img src="image-20201124211901569.png" alt="表4"></p><h5 id="精度和显存比较"><a href="#精度和显存比较" class="headerlink" title="精度和显存比较"></a>精度和显存比较</h5><p><img src="image-20201124212119447.png" alt="表5"></p><h4 id="Inria-Aerial"><a href="#Inria-Aerial" class="headerlink" title="Inria Aerial"></a>Inria Aerial</h4><p>包含180张超分图，每个都是5000×× 5000像素，随机划分训练验证测试为126，27，27张。表6说明了深度特征图共享策略的有效性。测试结果如表7，GLNet的mIoU有71.2%，在显存占用和准确率上都比其他方法要好。</p><p><img src="image-20201124212315576.png" alt="表6"></p><p><img src="image-20201124212343099.png" alt="表7"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>提出了GLNet做超分辨率图像分割，综合利用了全局上下文和局部精细信息提高了在超分辨率上的效果，并且没有多大的显存占用。同时也通过由粗到细的分割法解决类别不平衡问题。</p><p>在超分辨率中，效率和精度的平衡至关重要，这篇文章的工作是超分辨率分割效率和精度的先驱。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分辨率语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CascadePSP</title>
      <link href="/2020/11/17/cascadepsp/"/>
      <url>/2020/11/17/cascadepsp/</url>
      
        <content type="html"><![CDATA[<h1 id="CascadePSP-Toward-Class-Agnostic-and-Very-High-Resolution-Segmentation-via-Global-and-Local-Refinement"><a href="#CascadePSP-Toward-Class-Agnostic-and-Very-High-Resolution-Segmentation-via-Global-and-Local-Refinement" class="headerlink" title="CascadePSP: Toward Class-Agnostic and Very High-Resolution Segmentation via Global and Local Refinement"></a>CascadePSP: Toward Class-Agnostic and Very High-Resolution Segmentation via Global and Local Refinement</h1><p>通过全局和局部细化实现类不可知和非常高分辨率的分割</p><p><a href="https://arxiv.org/abs/2005.02551" target="_blank" rel="noopener">论文地址</a></p><p><a href="https://github.com/hkchengrex/CascadePSP" target="_blank" rel="noopener">代码地址</a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>语义分割一般只训练固定分辨率范围内的图像，通过对低分辨率图像上采样得到高分辨率图像是不足以描述高分辨率图像细节的。</li><li>受限于显存，低分辨率的模型没法推广到高分辨率情况</li><li>超分辨率图像标注难以获取</li><li>目前的超分图分割主要方法包括下采样和裁剪，下采样方法消除了细节信息，裁剪方法破坏了图像块之间的上下文信息</li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>提出了CascadePSP，这是一种通用的级联分割细化模型，它可以细化任何给定的输入分割，在不进行微调的情况下提高先进分割模型的性能。</li><li>证明了该方法可以产生高质量和高分辨率的分割，这是以前基于深度学习的方法所不能实现的。</li><li>做了个数据集，叫BIG dataset，有50个验证和100个测试，它可以作为一个精确的评价数据集用于非常高分辨率的语义图像分割任务。</li></ul><h2 id="Related-Works"><a href="#Related-Works" class="headerlink" title="Related Works"></a>Related Works</h2><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p>全卷积网络（FCN），通过自下而上的，带有广视野的上下文信息</p><p>特征金字塔（PSP），使用不同尺度的图像、或者是源于空间池化、拓展卷积等获得的不同感受野特征</p><p>编码器解码器（Encoder-Decoder），先减少维度捕获高级语义，然后使用解码器回复空间范围，再加上跳跃链接获得更清晰的边界。</p><h3 id="细化分割"><a href="#细化分割" class="headerlink" title="细化分割"></a>细化分割</h3><p>基于FCN的方法通常不会产生高质量的分割。研究人员已经用图结构模型解决了这个问题，如条件随机场（CRF）或区域生长。它们通常坚持低层次的颜色边界，而没有充分利用高级语义信息，并且不能修复较大的错误区域。由于计算和内存的限制，基于传播的方法不能处理非常高分辨率的数据。单独的细分模块也被用于提高边界精度，他们的模型接受的是端到端的训练，这种方法的模型，使用大模型容易出现过拟合，而浅层优化网络的优化能力有限。</p><h3 id="级联网络"><a href="#级联网络" class="headerlink" title="级联网络"></a>级联网络</h3><p>多尺度分析在许多计算机视觉任务中同时利用了大尺度和小尺度特征，如边缘检测、目标检测和分割。特别是，有许多方法在每个阶段预测独立的结果，并将它们合并以获得多尺度信息。我们的方法不仅从粗糙的尺度中融合特征，而且使用它们作为下一个更精细的层次的输入之一。文章证明，添加粗的输出作为下一层的输入并不会改变系统模型，因此同样的网络可以递归地用于更高分辨率的细化。</p><h2 id="CascadePSP"><a href="#CascadePSP" class="headerlink" title="CascadePSP"></a>CascadePSP</h2><h3 id="Refinement-Module"><a href="#Refinement-Module" class="headerlink" title="Refinement Module"></a>Refinement Module</h3><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p><img src="1.png" alt=""></p><p>单个细分模块如图所示，细分模块用不同的比例拍摄图像和多个不完美的分割mask来生成精确的分割。 多尺度输入使模型能够捕获不同层次的结构和边界信息，使网络能够学习自适应地融合不同尺度的mask特征，在最精细的层次上完善分割。</p><p>所有较低分辨率的输入分割均被双线性上采样为相同大小，并与RGB图像连接在一起。使用ResNet-50作为主干网络的PSPNet来从输入中提取步长为8的特征图。其中金字塔池化大小为[1,2,3,6]，这有助于捕获全局上下文。除了最终的OS 1输出之外，模型还生成了1/8和1/4的分割结果，并跳过1/2来提供纠正局部错误边界的灵活性。</p><p>为了重建在提取过程中丢失的像素级图像细节，采用了来自主干网络的跳跃连接，并使用上采样模块融合了特征。将skip分支的特征和来自主干分支的双线性上采样的特征连接起来，并使用两个ResNet块对其进行处理。使用2层1×1conv生成分割输出，然后进行sigmoid函数激活。</p><h4 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h4><p>1/8 采用交叉熵loss，os1采用L1+L2 loss ，1/4 采用交叉熵和L1+L2的平均值。不同的大小采用不同的loss，因为粗略分割主要是全局的结构忽略局部细节，而细化分割主要是依赖于局部分割的像素级的准确。为了更好的细化边缘，在os1输出上也采用了分割梯度幅度的L1损失。 分割梯度由3×3平均滤波器和Sobel算子估计， 由于梯度与像素级损失相比更稀疏，文章用α来衡量它，在实验中被设置为5。</p><p>（Sobel算子主要用于获得数字图像的一阶梯度，常见的应用和物理意义是边缘检测。索贝尔算子是把图像中每个像素的上下左右四领域的灰度值加权差，在边缘处达到极值从而检测边缘。）</p><script type="math/tex; mode=display">\mathcal{L}_{g r a d}=\alpha \cdot \frac{1}{n} \sum_{i}\left\|\nabla\left(f_{m}\left(x_{i}\right)\right)-\nabla\left(f_{m}\left(y_{i}\right)\right)\right\|_{1}</script><script type="math/tex; mode=display">\mathcal{L}=\mathcal{L}_{C E}^{8}+\frac{1}{2}\left(\mathcal{L}_{L 1+L 2}^{4}+\mathcal{L}_{C E}^{4}\right)+\mathcal{L}_{L 1+L 2}^{1}+\mathcal{L}_{g r a d}^{1}​</script><h4 id="Ablation-Study-of-Refinement-Module"><a href="#Ablation-Study-of-Refinement-Module" class="headerlink" title="Ablation Study of Refinement Module"></a>Ablation Study of Refinement Module</h4><p><img src="2.png" alt=""></p><p>评估方法使用标准分割度量IoU。为了突出边界精度的感性重要性，文章提出了一种新的平均边界精度度量(mBA)。为了对不同大小的图像进行鲁棒估计，我们在半径为[3,w+h 300]中进行均匀采5个样本，在真值边界内的每个半径范围内计算分割精度，然后对这些值进行平均。表1显示，文章提出的模型在IoU方面取得了最显著的改进，在边界精度方面甚至更显著。</p><p>通过多级级联，模块可以将不同的细化阶段委托给不同的规模。如图3所示，这个3级模型使用了中间的小规模分段来更好地捕获对象结构。尽管模型有着相同的感受野，但3级模型相比于1级模型可以更好地利用结构线索产生更详细的分割。</p><h3 id="Global-and-Local-Cascade-Refinement"><a href="#Global-and-Local-Cascade-Refinement" class="headerlink" title="Global and Local Cascade Refinement"></a>Global and Local Cascade Refinement</h3><p>在测试中，使用全局步骤和局部步骤通过采用相同的优化模块来执行高分辨率分割优化。具体来说，“全局”步骤考虑将整个调整大小后的图像用于修复结构，而“局部”步骤则使用图像裁剪以全分辨率优化细节。可以将相同的优化模块递归用于更高分辨率的优化。</p><h4 id="Global-Step"><a href="#Global-Step" class="headerlink" title="Global Step"></a>Global Step</h4><p><img src="3.png" alt=""></p><p>图4详细介绍了Global步骤的设计，该步骤使用3级级联优化整个图像。由于测试过程中的全分辨率图像通常无法放入GPU进行处理，因此首先对输入进行降采样，以使较长的轴具有L长度的同时保持相同的纵横比。</p><p>级联的输入使用input segmentation进行初始化，并进行复制以保持输入通道尺寸固定。在级联的第一级之后，其中一个输入通道将被双线性向上采样的粗略输出代替。重复此操作直到最后一级，其中输入既包含初始的分割结果，也包含来自先前级别的所有输出。</p><p>此设计使网络能够逐步修复分割的错误，同时保留初始分割结果中的详细信息。使用多个层次，可以粗略地勾画出对象，并在粗略层次中修复较大的误差，同时使用粗略层次提供的更强大的特征。这使得整个网络专注于精细层次的边界精度。</p><h4 id="Local-Step"><a href="#Local-Step" class="headerlink" title="Local Step"></a>Local Step</h4><p><img src="4.png" alt=""></p><p>图5说明了Local步骤的细节。由于内存的限制，即使使用GPU，也无法单次处理非常高分辨率的图像。而且，训练数据和测试数据之间规模的急剧变化将导致分割质量变差。因此，这篇文章利用级联模型首先使用降采样后的图像执行全局优化，然后使用来自高分辨率图像的图像裁剪执行局部优化。这些剪裁使Local步骤能够在不考虑高分辨率训练数据的情况下处理高分辨率图像，同时Global步骤能够将图像上下文考虑在内。</p><p>在局部步骤中，模型采用全局步骤最后一级的两个输出，两个输出均被线性调整为图像的原始尺寸W×H。模型对图像进行尺寸为L×L的裁剪，裁剪输出的每边将被削去16个像素，以避免边界伪影，但图像边界处有例外。裁剪的步幅统一为<strong>L/2-32</strong>，这样大部分像素被4个裁剪覆盖，超出图像边界的无效裁剪被移位到与图像的最后一行/一列对齐。然后将图像裁剪送入2级级联，步幅分别为4和1。在融合过程中，由于图像上下文不同，不同补丁的输出可能会有差异，我们通过对所有输出值进行平均来解决这个问题。 <strong>对于分辨率更高的图像，可以采用从粗到细的方式递归应用局部步骤。</strong></p><p>对于L的选择实验如下</p><p><img src="5.png" alt=""></p><h4 id="Ablation-Study-for-Global-and-Local-Refinement"><a href="#Ablation-Study-for-Global-and-Local-Refinement" class="headerlink" title="Ablation Study for Global and Local Refinement"></a>Ablation Study for Global and Local Refinement</h4><p><img src="6.png" alt=""></p><p><img src="7.png" alt=""></p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>数据集：PASCAL  VOC  2012 , ADE20K,BIG(自己标出来的)</p><p>评价指标：mIoU、mBA（自己提出的）</p><p><strong>训练方法：</strong>在训练过程中，随机抽取224×224个图像crop，并通过扰动ground truth来生成输入分割。具体扰动方法如下图所示：</p><p><img src="8.png" alt=""></p><p>实验结果可视化：</p><p><img src="9.png" alt=""></p><p><img src="10.png" alt=""></p><p>对比实验：</p><p><img src="11.png" alt=""></p><p><img src="12.png" alt=""></p><p>场景分割：</p><p><img src="13.png" alt=""></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这是一个通用的分割细化框架，用于细化任何输入分割，并在没有任何微调的情况下获得更高的精度。<br>CascadePSP执行高分辨率分割细化，即使模型从未见过任何高分辨率训练图像。<br>在低分辨率数据上训练单一的细化模块，提出的全局步骤对整个图像进行细化，并为后续的局部步骤提供足够的图像上下文来执行全分辨率高质量的细化。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 超分辨率语义分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql语法记录</title>
      <link href="/2020/10/18/mysql-yu-fa-ji-lu/"/>
      <url>/2020/10/18/mysql-yu-fa-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h1><pre class=" language-lang-sql"><code class="language-lang-sql">show databases; --查看数据库use school; --切换到school数据库show tables; --查看数据表describe student;--显示数据库中，表的信息,表结构desc student;--显示数据库中，表的信息,表结构create database if not exists newdbname;--创建一个数据库drop database if exists newdbname;--创建一个数据库create table if not exists `newtable`(    `id` int(4) not null auto_increment comment `学号`,    `name` varchar(30) not null default `匿名` comment `姓名`,    `pwd` varchar(20) not null default `123456` comment `密码`    primary key(`id`))engine=innoob default charset=utf8alter table tablename rename as newtable--修改表名--增加表的字段 alter:table 表名 add 字段名 列属性alter table tablename add age int(11) --增加表的字段 add 字段名 列属性--修改表的字段的约束:alter table 表名 modify 字段名 列属性alter table tablename modify age varchar(11)--修改表中字段的约束--修改表的字段的名字:alter table 表名 change 字段名 新的字段名 列属性alter table tablename change age age1 int(1)--字段重命名--删除表的字段:alter table 表名 drop 字段名alter table tablename drop age--删除表的字段--不推荐使用外键，建议在应用层实现--增加外键:alter table 表名 add constraint `FK_gradeid` foreign key(作为外键的列) references 那个表名(哪个字段)alter table `student` add constraint `FK_gradeid` foreign key(`gradeid`) references `grade`(`gradeid`)--由于主键自增，可以省略主键（如果不写表的字段，他会一一匹配）--insert into 表名([字段名1,字段名2,...])values('值1','值2',...)insert into `grade`(`gradename`,`name`)values('研二','aaa'),('研一','bbb')--update 表名 set 列名=新值[,colnum_name=value,...] where 条件update `student` set `name` = 'aaaaa',`email`='123123@qq.com' where id = 1;--清空数据表truncate `student`--重新设置自增列，不会影响事务delete from `student`--不会重新设置自增列--删除指定数据delete from `student` where id=1;--查询全部学生 select 字段(可以是表达式) from 表select * from student --查询指定字段select `StudentNo`,`StudentName` from studentselect `StudentNo` as 学号,`StudentName` as 学生姓名 from student as s--使用as起别名--select concat(a,b) as 新名字 from 表select concat('姓名：'StudentName) as 新名字 from student--select去重select distinct `StudentNo` from result--where 模糊查询 like   %：任意数量字符，_:单个字符select `StudentNo` from `student` where `StudentName` like ')刘%'--where 查询多个结果 inselect `StudentNo` from `student` where `address` in ('安徽','湖南')--inner join如果表中至少有一个匹配行，--left join从左表中返回所有的值，即使右表中没有匹配--right join从右表中返回所有的值，即使左表中没有匹配--on 用于多表，返回单表后用whereselect s.StudentNo,studentName from student as sinner join result as ron s.StudentNo=r.StudentNo</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM探究</title>
      <link href="/2020/10/17/jvm-tan-jiu/"/>
      <url>/2020/10/17/jvm-tan-jiu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM探究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解与反射</title>
      <link href="/2020/09/27/zhu-jie-yu-fan-she/"/>
      <url>/2020/09/27/zhu-jie-yu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li>不是程序本身，可以对程序作出解释</li><li>可以被其他程序（比如：编译器）读取。<h2 id="注解的格式"><a href="#注解的格式" class="headerlink" title="注解的格式"></a>注解的格式</h2>@注解名（参数）如：</li><li>重写：@Override、函数式接口@FunctionalInterface</li><li>带参例子：@SuppressWarnings(value=”unchecked”)<h2 id="在哪使用"><a href="#在哪使用" class="headerlink" title="在哪使用"></a>在哪使用</h2>package,class,method,field等上面，相当于给他们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><ul><li>@Override：重写；</li><li>@Deprecated：不鼓励程序员使用，或者使用更好的方式，弃用的；</li><li>@SuppressWarnings(“all”)：抑制编译时候带来的warning信息。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>注解其他注解的注解</p><ul><li>@Target：用于描述注解的适用范围（即：被描述的注解可以用在什么地方）</li><li>@Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（SOURCE&lt;CLASS&lt;RUNTIME）</li><li>@Document:说明该注解将被包含在javadoc中</li><li>@Inherited:表示子类可以继承父类的注解</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><pre class=" language-lang-java"><code class="language-lang-java">public class Annotation {    @MyAnnotation(name = "666",schools = {"牛逼"})//注解可以显示赋值，如果没有默认值则必须赋值    public void test(){    }}@Target({ElementType.TYPE,ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation{    String name() default "";//注解的参数，参数类型+参数名    int age() default 1;    String[] schools();}</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul><li>动态语言：可以在运行时根据某些条件改变自身结构，如：js，python，php等</li><li>静态语言：运行时结构不可变的语言，如：Java，C/C++</li><li>Java可通过反射实现一定的动态性</li><li><p>类、接口、数组、枚举、注解、基本数据类型、void均可以有Class对象</p><pre class=" language-lang-java"><code class="language-lang-java">  public static void test(){      Class c1 = MyAnnotation.class;//注解      Class c2 = Object.class;//类      Class c3 = Comparable.class;//接口      System.out.println(c1);      System.out.println(c2);      System.out.println(c3);  }</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解与反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程</title>
      <link href="/2020/09/27/java-wang-luo-bian-cheng/"/>
      <url>/2020/09/27/java-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="网络处理"><a href="#网络处理" class="headerlink" title="网络处理"></a>网络处理</h1><h2 id="TCP聊天"><a href="#TCP聊天" class="headerlink" title="TCP聊天"></a>TCP聊天</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;public class Client {    public static void main(String[] args) {        Socket socket = null;        OutputStream os = null;        try{            InetAddress serverIP = InetAddress.getByName("127.0.0.1");            int port = 9999;            socket = new Socket(serverIP,port);            os = socket.getOutputStream();            os.write("66666".getBytes());        }catch (Exception e){            e.printStackTrace();        }finally {            if (os != null) {                try {                    os.close();                } catch (IOException e) {                    e.printStackTrace();                }            }            if (socket != null) {                try {                    socket.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class Server {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = null;        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try{            serverSocket = new ServerSocket(9999);            while (true){                socket = serverSocket.accept();                is = socket.getInputStream();                baos = new ByteArrayOutputStream();                byte[] buffer = new byte[1024];                int len;                while((len=is.read(buffer))!=-1){                    baos.write(buffer,0,len);                }                System.out.println(baos.toString());            }        }catch (IOException e){            System.out.println(e.toString());        }finally {            if (baos != null) {                baos.close();            }            if (is != null) {                is.close();            }            if (socket != null) {                socket.close();            }            if (serverSocket != null) {                serverSocket.close();            }        }    }}</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class FileAccept {    public static void main(String[] args) throws IOException {        ServerSocket serverSocket = new ServerSocket(9000);        Socket socket = serverSocket.accept();        InputStream is = socket.getInputStream();        FileOutputStream fos = new FileOutputStream(new File("receive.jpg"));        byte[] buffer = new byte[100000];        int len;        while((len=is.read(buffer))!=-1) {            fos.write(buffer, 0, len);        }        fos.close();        is.close();        socket.close();        serverSocket.close();    }}</code></pre><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import com.sun.org.apache.xml.internal.serializer.OutputPropertyUtils;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class FileUpload {    public static void main(String[] args) throws IOException {        Socket socket = new Socket(InetAddress.getByName("127.0.0.1"),9000);        OutputStream os = socket.getOutputStream();        FileInputStream fis = new FileInputStream(new File("111.jpg"));        byte[] buffer = new byte[100000];        int len;        while((len=fis.read(buffer))!=-1){            os.write(buffer,0,len);        }        fis.close();        os.close();        socket.close();    }}</code></pre><h2 id="UDP发送"><a href="#UDP发送" class="headerlink" title="UDP发送"></a>UDP发送</h2><pre class=" language-lang-java"><code class="language-lang-java">InetAddress localhost = InetAddress.getByName("localhost");int port = 9999;String msg = "你好";DatagramSocket socket = new DatagramSocket();DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,(msg.getBytes().length,localhost,port);socket.send(packet);socket.close();</code></pre><h2 id="URL下载网络资源"><a href="#URL下载网络资源" class="headerlink" title="URL下载网络资源"></a>URL下载网络资源</h2><pre class=" language-lang-java"><code class="language-lang-java">package com.youtao;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class URLDemo {    public static void main(String[] args) throws IOException {        URL url = new URL("https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mMDZjNzU2NS0wZjg0LTQzNmItOGVlNy1hY2Y2ZjliN2VjMDIucG5n?x-oss-process=image/format,png");        System.out.println(url.getProtocol());//协议        System.out.println(url.getHost());//主机        System.out.println(url.getPort());//端口        System.out.println(url.getPath());//文件地址        System.out.println(url.getFile());//文件全路径        System.out.println(url.getQuery());//参数        //连接        HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();        InputStream inputStream = urlConnection.getInputStream();        FileOutputStream fileOutputStream = new FileOutputStream("112.png");        byte[] buffer = new byte[1024];        int len;        while ((len=inputStream.read(buffer))!=-1){            fileOutputStream.write(buffer,0,len);        }        fileOutputStream.close();        inputStream.close();        urlConnection.disconnect();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model-Based协同过滤算法</title>
      <link href="/2020/09/26/model-based-xie-tong-guo-lu-suan-fa/"/>
      <url>/2020/09/26/model-based-xie-tong-guo-lu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Model-Based协同过滤算法"><a href="#Model-Based协同过滤算法" class="headerlink" title="Model-Based协同过滤算法"></a>Model-Based协同过滤算法</h1><ul><li>基于分类算法、回归算法、聚类算法</li><li>基于矩阵分解的推荐</li><li>基于神经网络</li><li>基于图模型</li></ul><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p>这个用户或物品普遍高于或低于平均值的差值，成为偏差（bias）。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>找出每个用户普遍高于或低于他人的偏置值$b_{u}$</li><li>找出每件物品普遍高于或低于其他物品的偏置值$b_{i}$</li><li>目标转换为寻找最优的$b_{u}$和$b_{i}$</li></ul><h3 id="预测步骤"><a href="#预测步骤" class="headerlink" title="预测步骤"></a>预测步骤</h3><ul><li>计算所有电影的均分$\mu$</li><li>计算每个用户评分与平均评分$\mu$的偏置值$b_{u}$</li><li>计算每部电影所接受的评分与平均评分$\mu$的偏置值$b_{I}$</li><li>预测用户对电影的评分：<script type="math/tex; mode=display">\hat{r}_{ui}=b_{ui}=\mu + b_{u}+b_{i}</script></li><li>转换为损失优化的过程<script type="math/tex; mode=display">J(\theta)=Cost=f(b_{u},b_{i})</script><script type="math/tex; mode=display">J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu -b_{u}-b_{i})^2+\lambda *(\sum_{u}{b_{u}}^2+\sum_{i}{b_{i}}^2)</script></li></ul><h2 id="FunkSVD-LFM"><a href="#FunkSVD-LFM" class="headerlink" title="FunkSVD(LFM)"></a>FunkSVD(LFM)</h2><p>原始的SVD要求矩阵中每个元素非空，如果做填充，会造成大量噪声，破坏原始分布。</p><ul><li><p>P为User-LF矩阵，即用户-隐藏特征矩阵</p></li><li><p>Q为Item-LF矩阵</p></li><li><p>R=P*Q，为User-Item矩阵</p></li><li><p>能处理稀疏评分矩阵</p></li></ul><p>利用矩阵分解技术，将原始User-Item评分矩阵分解为P、Q，然后用P、Q利用梯度下降去还原R，整个过程相当于降维。</p><h2 id="BiasSVE"><a href="#BiasSVE" class="headerlink" title="BiasSVE"></a>BiasSVE</h2><p>矩阵分解+baseline思想</p><h2 id="SVD"><a href="#SVD" class="headerlink" title="SVD++"></a>SVD++</h2><p>矩阵分解+baseline思想+其他影响（点击、收藏、购买）</p>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Model-Based协同过滤算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于内容的推荐</title>
      <link href="/2020/09/26/ji-yu-nei-rong-de-tui-jian/"/>
      <url>/2020/09/26/ji-yu-nei-rong-de-tui-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h1><ul><li>给物品打标签<ul><li>系统自己提取，从业务数据库中提取</li><li>用户填写</li><li>中文分词 利用算法计算词的权重<ul><li>tf-idf:$\quad tf*idf$<ul><li>tf:term frequency词频</li><li>idf:逆文档频率 $log_{10}\frac{t}{n}$</li></ul></li><li>textrank</li></ul></li></ul></li><li>利用标签的文字，转换为词向量<ul><li>word2vec 词-&gt;向量</li><li>用向量表示语义</li><li>如果两个词向量的相似度高，认为两词语义相近</li></ul></li><li>利用词向量，构建物品的向量<ul><li>一个物品有N个关键词，每一个关键词对应一个词向量</li><li>求和（权重*词向量）/N</li><li>利用N个关键词的词向量获取物品向量</li></ul></li><li>通过物品向量计算相似度<ul><li>皮尔逊 相关系数 计算物品向量的相似度</li></ul></li></ul><h2 id="基于内容的推荐与基于物品的协同过滤的区别"><a href="#基于内容的推荐与基于物品的协同过滤的区别" class="headerlink" title="基于内容的推荐与基于物品的协同过滤的区别"></a>基于内容的推荐与基于物品的协同过滤的区别</h2><ul><li>基于内容：词向量-&gt;物品向量-&gt;计算相似度</li><li>基于物品：用户-物品矩阵-&gt;物品向量-&gt;相似度</li><li>差异：<ul><li>物品向量构建过程不同</li><li>基于内容<ul><li>物品向量 文本（物品描述信息，系统填标签，用户填标签）</li></ul></li><li>基于物品<ul><li>用户对物品的评分矩阵，用户的行为数据</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memory-Based推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统评估</title>
      <link href="/2020/09/26/tui-jian-xi-tong-ping-gu/"/>
      <url>/2020/09/26/tui-jian-xi-tong-ping-gu/</url>
      
        <content type="html"><![CDATA[<h1 id="推荐系统评估"><a href="#推荐系统评估" class="headerlink" title="推荐系统评估"></a>推荐系统评估</h1><h2 id="常用评估指标"><a href="#常用评估指标" class="headerlink" title="常用评估指标"></a>常用评估指标</h2><p>准确性、信任度、满意度、实时性、覆盖率、鲁棒性、多样性、可拓展性、新颖性、商业目标、惊喜度、用户留存。</p><h2 id="准确性（理论角度）"><a href="#准确性（理论角度）" class="headerlink" title="准确性（理论角度）"></a>准确性（理论角度）</h2><ul><li>评分预测<br>RMSE MAE</li><li>topN推荐<br>召回率、精准率<h2 id="覆盖度"><a href="#覆盖度" class="headerlink" title="覆盖度"></a>覆盖度</h2></li><li>信息熵，越大越好</li><li>覆盖率<h2 id="多样性-amp-新颖性-amp-惊喜性"><a href="#多样性-amp-新颖性-amp-惊喜性" class="headerlink" title="多样性&amp;新颖性&amp;惊喜性"></a>多样性&amp;新颖性&amp;惊喜性</h2>往往会牺牲准确性<h3 id="Exploitation-amp-Exploration探索与利用问题"><a href="#Exploitation-amp-Exploration探索与利用问题" class="headerlink" title="Exploitation &amp; Exploration探索与利用问题"></a>Exploitation &amp; Exploration探索与利用问题</h3></li><li>(Exploitation)开发、利用：选择现在可能的最佳方案</li><li>(Exploration)探索、搜索：选择现在不确定的一些方案，但未来可能会有高收益的方案</li><li>在做两类决策的过程中，不断更新对所有决策的不确定性的认知，优化长期的目标</li></ul><h3 id="EE问题实践"><a href="#EE问题实践" class="headerlink" title="EE问题实践"></a>EE问题实践</h3><ul><li>兴趣拓展：相似话题，搭配推荐</li><li>人群算法：userCF用户聚类</li><li>平衡个性化推荐和热门推荐比例</li><li>随机丢弃用户行为历史</li><li>随机扰动模型参数<h3 id="EE带来的可能问题"><a href="#EE带来的可能问题" class="headerlink" title="EE带来的可能问题"></a>EE带来的可能问题</h3></li><li>伤害用户体验</li><li>评估周期长</li><li>如何平衡实时兴趣和长期兴趣</li><li>如何平衡短期产品体验和长期系统生态</li><li>如何平衡大众口味和小众需求<h3 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h3></li><li>问卷</li><li>离线评估<ul><li>只能在用户看到过得候选集上评估（RMSE MAE），且跟线上真实效果存在偏差</li><li>只能评估少数指标</li><li>速度快，不影响用户体验</li></ul></li><li>在线评估：灰度发布&amp;A/B测试50%全量上线（类似于内测）</li><li>实践：离线评估和在线评估，定期做问卷调查</li></ul><h2 id="冷启动问题"><a href="#冷启动问题" class="headerlink" title="冷启动问题"></a>冷启动问题</h2><p>新用户，新物品，没有相关积累数据</p><h3 id="用户冷启动"><a href="#用户冷启动" class="headerlink" title="用户冷启动"></a>用户冷启动</h3><ul><li>收集用户特征<ul><li>注册信息</li><li>社交信息</li><li>定位、型号、app列表</li></ul></li><li>引导用户填写兴趣</li><li>用户在其他站点的行为</li><li>新老用户推荐策略的差异<ul><li>新用户在冷启动阶段更倾向于热门排行榜，老用户更需要长尾推荐</li><li>Explore Exploit力度</li><li>使用单独的特征和模型预估<h3 id="物品冷启动"><a href="#物品冷启动" class="headerlink" title="物品冷启动"></a>物品冷启动</h3></li></ul></li><li>物品打标签，构建物品画像</li><li>基于内容的推荐<h3 id="系统冷启动"><a href="#系统冷启动" class="headerlink" title="系统冷启动"></a>系统冷启动</h3></li><li>如果缺少用户行为数据-&gt;基于内容的推荐</li><li>随着用户行为积累越来越多-&gt;协同过滤</li><li>基于内容和协同过滤共同工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法评估 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法——协同过滤</title>
      <link href="/2020/09/15/tui-jian-suan-fa-xie-tong-guo-lu/"/>
      <url>/2020/09/15/tui-jian-suan-fa-xie-tong-guo-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="经典：协同过滤推荐算法"><a href="#经典：协同过滤推荐算法" class="headerlink" title="经典：协同过滤推荐算法"></a>经典：协同过滤推荐算法</h1><p>算法思想：物以类聚，人以群分。<br>基本假设：</p><ul><li>喜好相似的人洗好的东西你也很可能喜欢：基于用户的协同过滤推荐（User-based CF）</li><li>跟你喜欢的东西相似的东西你也很可能喜欢：基于物品的协同过滤推荐（item-based CF）</li></ul><h1 id="相似度计算"><a href="#相似度计算" class="headerlink" title="相似度计算"></a>相似度计算</h1><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><p>余弦相似性通过测量两个向量的夹角的余弦值来度量它们之间的相似性。0度角的余弦值是1，而其他任何角度的余弦值都不大于1；并且其最小值是-1。从而两个向量之间的角度的余弦值确定两个向量是否大致指向相同的方向。两个向量有相同的指向时，余弦相似度的值为1；两个向量夹角为90°时，余弦相似度的值为0；两个向量指向完全相反的方向时，余弦相似度的值为-1。这结果是与向量的长度无关的，仅仅与向量的指向方向相关。余弦相似度通常用于正空间，因此给出的值为0到1之间。</p><script type="math/tex; mode=display">\cos(\theta)=\frac{A \cdot B}{||A|| \cdot ||B||}</script><h2 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h2><p>本质上也是余弦相似度，用以度量两个变量是否是同增同减，主要衡量变量之间的变化趋势是否一致，不适合计算布尔值向量之间的相关度。</p><p>对余弦相似度所用的向量的每一个分量做中心化。</p><p>如果评分数据是连续的数值，比较适合余弦和皮尔逊</p><h2 id="杰卡德相似度"><a href="#杰卡德相似度" class="headerlink" title="杰卡德相似度"></a>杰卡德相似度</h2><p>计算适用于$bool$类型数据</p><script type="math/tex; mode=display">J(A,B)=\frac{|A \cap B|}{|A \cup B|}</script><h2 id="评分预测"><a href="#评分预测" class="headerlink" title="评分预测"></a>评分预测</h2><h3 id="基于用户"><a href="#基于用户" class="headerlink" title="基于用户"></a>基于用户</h3><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\frac{\sum{v\in U}sim(u,v)*r_{vi}}{\sum{v \in U}|sim(u,v)|}</script><h3 id="基于物品"><a href="#基于物品" class="headerlink" title="基于物品"></a>基于物品</h3><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\frac{\sum{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum{j \in I_{rate}}|sim(i,j)|}</script><h2 id="基于模型的协同过滤算法"><a href="#基于模型的协同过滤算法" class="headerlink" title="基于模型的协同过滤算法"></a>基于模型的协同过滤算法</h2><h3 id="基于图模型"><a href="#基于图模型" class="headerlink" title="基于图模型"></a>基于图模型</h3><ul><li>将用户行为数据表示为二分图</li><li>基于二分图为用户进行推荐</li><li>根据两个顶点之间的路径数、路径长度和经过的顶点数来评价两个顶点的相关性</li></ul><h3 id="基于矩阵分解的方法"><a href="#基于矩阵分解的方法" class="headerlink" title="基于矩阵分解的方法"></a>基于矩阵分解的方法</h3><ul><li>适用于解决稀疏数据</li><li>将M×N的用户-物品矩阵分解为M×K的用户矩阵和K×N的物品矩阵，取出第一行的1×K和第一列的K×1做点乘即为第一个用户对第一个物品的得分。</li><li>分解后的两矩阵相乘应尽可能等于原矩阵，损失函数为原矩阵与分解后重新乘起来的矩阵的L2距离。（利用ALS,交替最小二乘法优化)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memory-Based推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2020/09/12/java-duo-xian-cheng/"/>
      <url>/2020/09/12/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>线程开启不一定立即执行，由CPU调度</p><ul><li>继承Thread类，重写run()方法，调用start开启线程</li><li>通过实现MyRunnable接口<ol><li>定义MyRunnable类实现Runnable接口</li><li>实现run()方法</li><li>通过Thread类调用<pre class=" language-lang-java"><code class="language-lang-java">new Thread(threadname).start()</code></pre></li></ol></li><li>通过实现Callable接口(可以有返回值，可以抛出异常)<ol><li>定义TestCallable类实现Callable接口</li><li>实现call()方法,拥有返回值</li><li>创建执行服务、提交执行、获取结果、关闭服务<pre class=" language-lang-java"><code class="language-lang-java">TestCallable t1 = new TestCallable();TestCallable t2 = new TestCallable();TestCallable t3 = new TestCallable();//创建执行服务ExecutorService ser = Executors.newFixedThreadPool(nThreads);//提交执行Future<Boolean> r1 = ser.submit(t1);Future<Boolean> r2 = ser.submit(t2);Future<Boolean> r3 = ser.submit(t3);//获取结果boolean rs1 = r1.get();boolean rs2 = r2.get();boolean rs3 = r3.get();//关闭服务ser.shutdownNow();</code></pre><h2 id="获取线程信息"><a href="#获取线程信息" class="headerlink" title="获取线程信息"></a>获取线程信息</h2><pre class=" language-lang-java"><code class="language-lang-java">Thread.currentThread().getName()#获取线程名;</code></pre><h2 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h2></li></ol></li><li>真实对象和代理对象都要实现同一个接口</li><li>代理对象要代理真实角色<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3></li><li>代理对象可以做很多真实对象做不了的事情</li><li>真实对象专注做自己的事情</li></ul><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>不推荐使用jdk提供的stop()、destroy()等过时方法。</p><h4 id="设置外部标志位"><a href="#设置外部标志位" class="headerlink" title="设置外部标志位"></a>设置外部标志位</h4><ol><li>设置外部标志位</li><li>设置一个公开的方法停止线程————转换标志位<h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4></li></ol><ul><li>sleep存在异常InterruptedException</li><li>每个对象都有一个锁sleep不会释放锁<pre class=" language-lang-java"><code class="language-lang-java">try {  Thread.sleep(50);//括号内为毫秒数} catch (InterruptedException e) {  e.printStackTrace();}</code></pre><h4 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h4>礼让不一定成功<pre class=" language-lang-java"><code class="language-lang-java">class A implements Runnable{  @Override  public void run() {      System.out.println("yingyihg");      Thread.yield();      System.out.println("111");  }}</code></pre><h4 id="线程强制执行-插队"><a href="#线程强制执行-插队" class="headerlink" title="线程强制执行(插队)"></a>线程强制执行(插队)</h4><pre class=" language-lang-java"><code class="language-lang-java">thread.join();</code></pre><h4 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h4><pre class=" language-lang-java"><code class="language-lang-java">state = thread.getState();//state == Thread.State.TERMINATED;</code></pre><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><pre class=" language-lang-java"><code class="language-lang-java">//查看优先级Thread.currentThread.getPriority();//设置优先级thread.setPriority(1);thread.setPriority(Thread.MAX_PRIORITY);</code></pre><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4>线程分为用户线程和守护线程，虚拟机需要等待用户线程执行完毕而不会等待守护线程，守护线程用于垃圾回收，监控内存，后台日志记录等。<pre class=" language-lang-java"><code class="language-lang-java">thread.setDaemon(true);</code></pre></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>并发：多线程操作同一个资源</p><h3 id="引入锁机制synchronized"><a href="#引入锁机制synchronized" class="headerlink" title="引入锁机制synchronized"></a>引入锁机制synchronized</h3><p>问题：</p><ul><li>线程持有锁会导致其他所有需要此锁的线程挂起；</li><li>多线程竞争下，加锁，释放锁会导致较多的上下文切换和调度延时，引起性能问题；</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。<pre class=" language-lang-java"><code class="language-lang-java">public pynchronized void run();//同步方法，默认锁thissynchronized(obj){  //同步代码块，所得对象就是变化的量，需要增删改查的。}</code></pre><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3>java.util,concurrent.locks.Lock接口是控制多个线程对共享资源访问的工具。<h4 id="ReentrantLock类-可重入锁"><a href="#ReentrantLock类-可重入锁" class="headerlink" title="ReentrantLock类 可重入锁"></a>ReentrantLock类 可重入锁</h4>该类实现了Lock，拥有和synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用，可显式加锁释放锁。<pre class=" language-lang-java"><code class="language-lang-java">class TestLock2 implements Runnable{  int ticketNums = 10;  private final ReentrantLock lock = new ReentrantLock();  @Override  public void run() {      while (true){          try{              lock.lock();              if(ticketNums>0){                  try {                      Thread.sleep(1000);                  } catch (InterruptedException e) {                      e.printStackTrace();                  }                  System.out.println(ticketNums--);              }else break;          }finally {              lock.unlock();          }      }  }}</code></pre><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="生产者消费者问题-可以参考操作系统"><a href="#生产者消费者问题-可以参考操作系统" class="headerlink" title="生产者消费者问题(可以参考操作系统)"></a>生产者消费者问题(可以参考操作系统)</h3></li><li>管程法</li><li><p>信号灯法</p><pre class=" language-lang-java"><code class="language-lang-java">if(flag){    this.wait();}//执行操作this.notifyAll();</code></pre><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><pre class=" language-lang-java"><code class="language-lang-java">public class TestProduceConsumer {  public static void main(String[] args) {      SynContainer container = new SynContainer();      new Productor(container).start();      new Consumer(container).start();  }}class Productor extends Thread{  SynContainer container;  public Productor(SynContainer container){      this.container = container;  }  public void run(){      for (int i = 0; i < 100; i++) {          container.push(new Product(i));          System.out.println("生产了"+i+"只鸡");      }  }}class Consumer extends Thread{  SynContainer container;  public Consumer(SynContainer container){      this.container = container;  }  @Override  public void run() {      for (int i = 0; i < 100; i++) {          System.out.println("消费了第"+container.pop().id+"只鸡");      }  }}class Product{  int id;  public Product(int id) {      this.id = id;  }}class SynContainer{  Product[] products = new Product[10];  int count = 0;  public synchronized void push(Product product){      if(count==products.length){          try {              this.wait();          } catch (InterruptedException e) {              e.printStackTrace();          }      }      products[count]=product;      count++;      this.notifyAll();  }  public synchronized Product pop(){      if(count==0){          try {              this.wait();          } catch (InterruptedException e) {              e.printStackTrace();          }      }      count--;      Product product = products[count];      this.notifyAll();      return product;  }}</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>背景：经常创建和销毁、使用量特别大的资源，比如并发下的线程，对性能影响很大。<br>思路：提前创建多线程，放入线程池，使用时直接获取，使用完放回池中。</p><pre class=" language-lang-java"><code class="language-lang-java">class MyThread implements Runnable{  @Override  public void run() {      System.out.println(Thread.currentThread().getName());  }}public class TestPool {  public static void main(String[] args) {      //创建服务，创建线程池,参数为线程池大小      ExecutorService service = Executors.newFixedThreadPool(10);      //执行      service.execute(new MyThread());      service.execute(new MyThread());      service.execute(new MyThread());      service.execute(new MyThread());      //关闭链接      service.shutdown();  }}</code></pre><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>任何一个接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p></li></ul><p>定义以下接口及其类的实现</p><pre class=" language-lang-java"><code class="language-lang-java">interface Ilike{    void lambda();}</code></pre><pre class=" language-lang-java"><code class="language-lang-java">//表达式只有一行的时候可以省略花括号//lambda使用前提是函数式接口//如果有一个或者多个参数，可以去掉参数类型，但得所有一起去，必须加上小括号Ilike like = ()->{    System.out.println("i like lambda5");}like.lambda();</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程及lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类</title>
      <link href="/2020/09/12/java-chang-yong-lei/"/>
      <url>/2020/09/12/java-chang-yong-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li>hashcode()</li><li>toString()</li><li>clone()</li><li>getClass()</li><li>notify()//唤起等待状态的线程</li><li>wait()//线程等待，与sleep不同在他会释放锁</li><li>equals()</li></ul><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>常见的数学运算</p><pre class=" language-lang-java"><code class="language-lang-java">System.out.println("90度的正弦值：" + Math.sin(Math.PI / 2));System.out.println("2的平方根与2商的反弦值:" + Math.asin(Math.sqrt(2)/2));System.out.println("e的平方值："+ Math.exp(2));System.out.println("以e为底2的对数值:" + Math.log(2));System.out.println("以10为底2的对数值:" + Math.log10(2));System.out.println("2的平方根:" + Math.sqrt(2));System.out.println("2的平方:" + Math.pow(2,2));System.out.println("不小于3.5的最小整数" + Math.ceil(3.5));System.out.println("不大于3.5的最大整数:" + Math.floor(3.5));System.out.println("3.5的四舍五入:" + Math.round(3.5));System.out.println("3.5最接近的整数为，同样接近取偶数：" + Math.rint(3.5));</code></pre><h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>生成随机数</p><pre class=" language-lang-java"><code class="language-lang-java">Random r = new Random();//生成0-n之间随机整数int p = r.nextInt(n);//生成0-1之间随机doubledouble d1 = r.nextDouble();//设置随机种子r.setSeed(555L);</code></pre><h2 id="Data类"><a href="#Data类" class="headerlink" title="Data类"></a>Data类</h2><pre class=" language-lang-java"><code class="language-lang-java">Date d1 = new Date();//以正常形式创建当前日期d1long timeMillis = System.currentTimeMillis();//当前毫秒数Date d2 = new Date(timeMillis);//以毫秒数创建d2long value = d2.getTime();//获取当前时间（毫秒）System.out.println("日期" + d1);System.out.println("毫秒数" + value);</code></pre><p>输出结果为：</p><pre class=" language-lang-java"><code class="language-lang-java">日期Sat Sep 12 17:17:50 GMT+08:00 2020毫秒数1599902270831</code></pre><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><pre class=" language-lang-java"><code class="language-lang-java">DateFormat df1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss EE");DateFormat df2 = new SimpleDateFormat("yyyy年MM月dd日");Date date = new Date();System.out.println("格式化输出日期1：" + df1.format(date));System.out.println("格式化输出日期2：" + df2.format(date));</code></pre><p>输出结果为：</p><pre class=" language-lang-java"><code class="language-lang-java">格式化输出日期1：2020-09-12 06:37:56 星期六格式化输出日期2：2020年09月12日</code></pre><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><pre class=" language-lang-java"><code class="language-lang-java">Calendar c1 = Calendar.getInstance();c1.setTime(d1);         System.out.println(d);System.out.println(c1.get(Calendar.YEAR)+"年"+(c1.get(Calendar.MONTH)+1)+"月"+c1.get(Calendar.DATE)+"日");</code></pre><p>输出结果为：2020年9月12日</p><pre class=" language-lang-java"><code class="language-lang-java"></code></pre><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><p>创建文件对象</p><pre class=" language-lang-java"><code class="language-lang-java">File file = new File(filePath);</code></pre><p>创建文件/文件夹</p><pre class=" language-lang-java"><code class="language-lang-java">file.createNewFile();//文件file.mkdirs();//文件夹</code></pre><p>删除文件</p><pre class=" language-lang-java"><code class="language-lang-java">file.delete();</code></pre><p>递归删除文件夹</p><pre class=" language-lang-java"><code class="language-lang-java">public static void deleteDirectory(String filePath){        File file = new File(filePath);        if(!file.exists()){            return;        }        if(file.isFile()){            file.delete();        }else if(file.isDirectory()){            File[] files = file.listFiles();            for (File myfile : files) {                deleteDirectory(filePath + "/" + myfile.getName());            }            file.delete();        }}</code></pre><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>字节为单位读取，用于二进制文件，如图片、影像、音频</p><pre class=" language-lang-java"><code class="language-lang-java">public static String readFileByBytes(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        StringBuffer content = new StringBuffer();        try {            byte[] temp = new byte[1024];            FileInputStream fileInputStream = new FileInputStream(file);            while(fileInputStream.read(temp) != -1){                content.append(new String(temp));                temp = new byte[1024];            }            fileInputStream.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content.toString();}</code></pre><p>以字符为单位读取文件，用于读文本，数字等类型文件，支持中文</p><pre class=" language-lang-java"><code class="language-lang-java">public static String readFileByChars(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        StringBuffer content = new StringBuffer();        try {            char[] temp = new char[1024];            FileInputStream fileInputStream = new FileInputStream(file);            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "GBK");            while(inputStreamReader.read(temp) != -1){                content.append(new String(temp));                temp = new char[1024];            }            fileInputStream.close();            inputStreamReader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content.toString();}</code></pre><p>以行为单位读取文件，用于读面向行的格式化文件</p><pre class=" language-lang-java"><code class="language-lang-java">public static List<String> readFileByLines(String filePath){        File file = new File(filePath);        if(!file.exists() || !file.isFile()){            return null;        }        List<String> content = new ArrayList<String>();        try {            FileInputStream fileInputStream = new FileInputStream(file);            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "GBK");            BufferedReader reader = new BufferedReader(inputStreamReader);            String lineContent = "";            while ((lineContent = reader.readLine()) != null) {                content.add(lineContent);                System.out.println(lineContent);            }            fileInputStream.close();            inputStreamReader.close();            reader.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return content;}</code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>FileWriter</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByFileWriter(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            FileWriter fw = new FileWriter(filePath);            fw.write(content);            fw.close();        }}</code></pre><p>BufferedOutputStream</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByBufferedOutputStream(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(filePath));            fos.write(content.getBytes("GBK"));            fos.flush();            fos.close();        }}</code></pre><p>FileOutputStream</p><pre class=" language-lang-java"><code class="language-lang-java">public static void writeFileByFileOutputStream(String filePath, String content) throws IOException{        File file = new File(filePath);        synchronized (file) {            FileOutputStream fos = new FileOutputStream(filePath);            fos.write(content.getBytes("GBK"));            fos.close();        }}</code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>将基本类型转换为面向对象，类名为Byte，Boolean，Short，Character，Integer，Long，Float，Double。</p><pre class=" language-lang-java"><code class="language-lang-java">String s = "123";int n = Integer.parseInt(s);//将字符串"120"按照十进制转换为int,则结果为120int n = Integer.parseInt("120",10);//将字符串"12"按照十六进制转换为int,则结果为18int n = Integer.parseInt("12",16);//将字符串"ff"按照十六进制转换为int,则结果为255int n = Integer.parseInt("ff",16);int m = 1000;String s = Integer.toString(m);//将int值转换为特定进制的字符串</code></pre><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>不可变性</p><h2 id="可变String"><a href="#可变String" class="headerlink" title="可变String"></a>可变String</h2><p>StringBuffer多线程数据量较大/StringBuilder(效率高，不安全)单线程数据量较大</p><pre class=" language-lang-java"><code class="language-lang-java">public class Test{    public static void main(String args[]){        StringBuffer sBuffer = new StringBuffer("first");        sBuffer.append("second");        System.out.println(sBuffer);          sBuffer.delete(1,3);        System.out.println(sBuffer);         sBuffer.reverse()        System.out.println(sBuffer);     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/2020/09/11/git-shi-yong/"/>
      <url>/2020/09/11/git-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基本使用"><a href="#Git基本使用" class="headerlink" title="Git基本使用"></a>Git基本使用</h1><h2 id="必要配置"><a href="#必要配置" class="headerlink" title="必要配置"></a>必要配置</h2><h3 id="查看当前项目下的配置"><a href="#查看当前项目下的配置" class="headerlink" title="查看当前项目下的配置"></a>查看当前项目下的配置</h3><pre class=" language-lang-git"><code class="language-lang-git">git config -l  #查看所有配置git config --system -l #查看系统配置git config --global --list #查看用户配置</code></pre><h3 id="配置用户变量"><a href="#配置用户变量" class="headerlink" title="配置用户变量"></a>配置用户变量</h3><pre class=" language-lang-git"><code class="language-lang-git">git config --global user.name "YouTaoBaBa" #配置用户名git config --global user.email 674508620@qq.com #配置用户邮箱</code></pre><h2 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h2><p>用户目录下找.ssh文件夹里找-d_rsa.pub，如果没有，则使用以下命令生成公钥，然后将公钥复制到远程仓库管理(github,gitee,coding等)的ssh配置里</p><pre class=" language-lang-git"><code class="language-lang-git">ssh-keygen -t rsa</code></pre><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h3><pre class=" language-lang-git"><code class="language-lang-git">git init #本地初始化git clone [url](https或者ssh) #复制远程仓库</code></pre><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><pre class=" language-lang-git"><code class="language-lang-git">git add . #添加所有文件到暂存区</code></pre><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><pre class=" language-lang-git"><code class="language-lang-git">git status</code></pre><h3 id="提交暂存区至本地仓库"><a href="#提交暂存区至本地仓库" class="headerlink" title="提交暂存区至本地仓库"></a>提交暂存区至本地仓库</h3><pre class=" language-lang-git"><code class="language-lang-git">git commit -m "filename"</code></pre><h3 id="提交至远程仓库"><a href="#提交至远程仓库" class="headerlink" title="提交至远程仓库"></a>提交至远程仓库</h3><pre class=" language-lang-git"><code class="language-lang-git">git push (origin master)</code></pre><h3 id="同步远程仓库至本地仓库"><a href="#同步远程仓库至本地仓库" class="headerlink" title="同步远程仓库至本地仓库"></a>同步远程仓库至本地仓库</h3><pre><code>git pull</code></pre><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>在主目录下建立 “.gitignore”文件，文件规则如下：</p><ol><li>忽略文件中的空行和井号开始的行会被忽略</li><li>可以使用linux通配符</li><li>名称最前面有!表示例外规则，不被忽略</li><li>名称前面德文路径分隔符(‘/‘)表示要忽略的文件在此目录下，而子目录的文件不忽略</li><li>如果名称的最后一个是路径分隔符(‘/‘)表示忽略的是此目录下该名称的子目录，而非文件(默认文件或目录都忽略)。</li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看所有分支</p><pre class=" language-lang-git"><code class="language-lang-git">git branchgit branch -r #查看远程分支</code></pre><p>新建分支dev</p><pre class=" language-lang-git"><code class="language-lang-git">git branch devgit checkout -b dev #新建一个分支并切换到这个分支</code></pre><p>切换分支</p><pre class=" language-lang-git"><code class="language-lang-git">git checkout master</code></pre><p>删除分支dev</p><pre class=" language-lang-git"><code class="language-lang-git">git branch -d dev</code></pre><p>合并指定分支到当前分支</p><pre class=" language-lang-git"><code class="language-lang-git">git merge [branch]</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建Hexo博客</title>
      <link href="/2020/09/10/cong-ling-kai-shi-da-jian-hexo-bo-ke/"/>
      <url>/2020/09/10/cong-ling-kai-shi-da-jian-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   准备工作:安装nodejs, 安装git, 配置github的SSH</p></blockquote><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>进入<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a>下载稳定版本，一路点击next，安装完成后，打开cmd，输入命令<code>node -v</code>和<code>npm -v</code>，如果显示版本号，安装成功</p><p><img src="https://s1.ax1x.com/2020/09/10/wJYoXq.png" alt="wJYoXq.png"></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>进入<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>下载对应的安装文件，下载完成之后，设置用户名和邮箱，再配置Github账户的SSH</p><p>使用<code>git config --global user.name &quot;username&quot;</code>设置用户名，注意username是自己的GitHub用户名，邮箱是GitHub邮箱</p><p><img src="https://s1.ax1x.com/2020/09/10/wJt4UO.png" alt="wJt4UO.png"></p><p>使用<code>git config --global user.email &quot;email&quot;</code>设置邮箱，注意eamil指的是自己的GitHub绑定的邮箱</p><p><img src="https://s1.ax1x.com/2020/09/10/wJtT8H.png" alt="wJtT8H.png"></p><h3 id="配置github的SSH"><a href="#配置github的SSH" class="headerlink" title="配置github的SSH"></a>配置github的SSH</h3><p>进入到家目录的<code>.ssh</code>文件夹，输入<code>ssh-keygen -t rsa -C &quot;eamil&quot;</code>，这里的email是自己的GitHub绑定的邮箱地址，连续三个回车。在当前用户目录下的.ssh文件夹下，产生了两个文件，一个是公钥文件，一个是私钥文件。</p><p><img src="https://s1.ax1x.com/2020/09/10/wJNBLt.png" alt="wJNBLt.png"></p><p>复制公钥文件的内容，到GitHub网站，在<code>Settings</code>页面左边的<code>SSH and GPG keys</code>部分，新建一个SSH keys，粘贴刚刚复制过来的内容</p><p><img src="https://s1.ax1x.com/2020/09/10/wJNgJg.png" alt="wJNgJg.png"></p><p>再到Git中，输入<code>ssh -T git@github.com</code>，如果出现<strong>Hi，username</strong>，那么表明本地成功连接了GitHub</p><p><a href="https://imgchr.com/i/wJN4Lq" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/10/wJN4Lq.png" alt="wJN4Lq.png"></a></p><blockquote><p>  新建仓库存放博客内容，并且安装和美化Hexo</p></blockquote><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>新建一个项目， 名称为<code>账户名.github.io</code>，勾选<strong>Initialize this repository with a README</strong></p><p><img src="https://s1.ax1x.com/2020/09/10/wJUGXn.png" alt="wJUGXn.png"></p><p>点击项目的Settings,下拉到<strong>GitHub Pages</strong>部分，Source下拉框的选项如果是<code>None</code>，那么要改为<code>master branch</code>，点击<code>save</code>按钮保存，上方会显示一个网址，这个就是被部署到外网的网址，能够通过外网访问</p><p><img src="https://s1.ax1x.com/2020/09/10/wJUwhF.png" alt="wJUwhF.png"></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在本地创建一个文件夹，作为博客系统的根目录，进入到这个目录</p><p>输入<code>npm install hexo -g</code>，开始安装Hexo</p><p>输入<code>hexo -v</code>，检查hexo是否安装成功</p><p>输入<code>hexo init</code>，初始化该文件夹</p><p>输入<code>npm install</code>，安装所需要的组件</p><p>输入<code>hexo g</code>，g是generate的缩写</p><p>输入<code>hexo s</code>，s是start的缩写，表明开启服务器，此时浏览器打开该网址<code>localhost:4000</code></p><p>如果出现下图，那么Hexo就搭建成功了</p><p><img src="https://s1.ax1x.com/2020/09/10/wJULAf.png" alt="wJULAf.png"></p><p>目前只能本地访问到，下面配置外网访问</p><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>配置deployment，在项目文件夹中，找到配置文件<strong>_config.yml</strong>，修改repo的值，增加<strong>branch</strong>的值为<strong>master</strong></p><p><img src="https://s1.ax1x.com/2020/09/10/wJaPH0.png" alt="wJaPH0.png"></p><p>repo的值是GitHub项目右下角，<strong>Use SSH</strong>的，以<strong>git</strong>结尾的一个链接， 默认是<strong>Use HTTPS</strong>，使用<strong>Use SSH</strong>选项就能看到以<strong>git</strong>结尾的链接。复制这个以<strong>git</strong>结尾的链接，粘贴到配置文件<strong>_config.yml</strong>，修改repo的值</p><p><img src="https://s1.ax1x.com/2020/09/10/wJakNT.png" alt="wJakNT.png"></p><p>cmd进入博客根目录，安装一个扩展，<code>npm install hexo-deployer-git --save</code></p><p>新建一片博客，在cmd进入根目录后，用<code>hexo new post &quot;文章名&quot;</code></p><p>输入命令<code>hexo g &amp;&amp; hexo d</code>，然后再输入Github Pages的网址就能够访问了</p><h3 id="美化主题"><a href="#美化主题" class="headerlink" title="美化主题"></a>美化主题</h3><p>默认的主题样式一般，选择更好看的主题matery</p><p>进入到<code>themes</code>文件夹</p><pre class=" language-lang-bash"><code class="language-lang-bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><p>修改 <code>_config.yml</code> 的 <code>url</code> 的值为网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</p><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-lang-bash"><code class="language-lang-bash">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre class=" language-lang-bash"><code class="language-lang-bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-lang-bash"><code class="language-lang-bash">search:  path: search.xml  field: post</code></pre><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><pre class=" language-lang-bash"><code class="language-lang-bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-lang-bash"><code class="language-lang-bash">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2020/09/10/markdown-ji-ben-yu-fa/"/>
      <url>/2020/09/10/markdown-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown学习"><a href="#Markdown学习" class="headerlink" title="Markdown学习"></a>Markdown学习</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><h3 id="标题级数-’-’个数"><a href="#标题级数-’-’个数" class="headerlink" title="标题级数=’#’个数"></a>标题级数=’#’个数</h3><p>字体格式<br><strong>粗体</strong><br><em>斜体</em><br><del>废弃线</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>油桃牛逼</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://coding-pages-bucket-3473233-7944306-346-307103-1302308732.cos-website.ap-hongkong.myqcloud.com/medias/featureimages/12.jpg" alt="截图"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://coding-pages-bucket-3473233-7944306-346-307103-1302308732.cos-website.ap-hongkong.myqcloud.com/" target="_blank" rel="noopener">跳转到油桃的博客首页</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>A</li><li>B</li><li>C</li></ol><ul><li>A</li><li>B</li><li>C</li></ul><div class="table-container"><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>1997.7</td></tr></tbody></table></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-lang-python"><code class="language-lang-python">import pdbpdb.set_trace()</code></pre><script type="math/tex; mode=display">\mathcal{D}^{\mathrm{hr}}=\{\{(\boldsymbol{I}_{i j}^{\mathrm{hr}}, \boldsymbol{S}_{i j}^{\mathrm{hr}})\}_{j=1}^{n_{i}}\}_{i=1}^{N}</script><script type="math/tex; mode=display">\hat{\pi}_{q_{i}}=\frac{count(q_{i}^{1})}{count(o_{1})}, s.t.\sum_{i} \pi_{q_{i}}=1</script>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog书写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/09/10/hello-world/"/>
      <url>/2020/09/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一次配置完成Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
